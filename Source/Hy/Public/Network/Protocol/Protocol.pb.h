// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
#include "Struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class BC_GL_CHAT;
struct BC_GL_CHATDefaultTypeInternal;
extern BC_GL_CHATDefaultTypeInternal _BC_GL_CHAT_default_instance_;
class BC_GL_ECHO;
struct BC_GL_ECHODefaultTypeInternal;
extern BC_GL_ECHODefaultTypeInternal _BC_GL_ECHO_default_instance_;
class CS_CHAT;
struct CS_CHATDefaultTypeInternal;
extern CS_CHATDefaultTypeInternal _CS_CHAT_default_instance_;
class CS_ECHO;
struct CS_ECHODefaultTypeInternal;
extern CS_ECHODefaultTypeInternal _CS_ECHO_default_instance_;
class CS_ENTER_ROOM;
struct CS_ENTER_ROOMDefaultTypeInternal;
extern CS_ENTER_ROOMDefaultTypeInternal _CS_ENTER_ROOM_default_instance_;
class CS_LOGIN;
struct CS_LOGINDefaultTypeInternal;
extern CS_LOGINDefaultTypeInternal _CS_LOGIN_default_instance_;
class CS_REGIST;
struct CS_REGISTDefaultTypeInternal;
extern CS_REGISTDefaultTypeInternal _CS_REGIST_default_instance_;
class SC_CHAT;
struct SC_CHATDefaultTypeInternal;
extern SC_CHATDefaultTypeInternal _SC_CHAT_default_instance_;
class SC_ENTER_ROOM;
struct SC_ENTER_ROOMDefaultTypeInternal;
extern SC_ENTER_ROOMDefaultTypeInternal _SC_ENTER_ROOM_default_instance_;
class SC_ENTER_ROOM_OTHERS;
struct SC_ENTER_ROOM_OTHERSDefaultTypeInternal;
extern SC_ENTER_ROOM_OTHERSDefaultTypeInternal _SC_ENTER_ROOM_OTHERS_default_instance_;
class SC_LOGIN;
struct SC_LOGINDefaultTypeInternal;
extern SC_LOGINDefaultTypeInternal _SC_LOGIN_default_instance_;
class SC_REGIST;
struct SC_REGISTDefaultTypeInternal;
extern SC_REGISTDefaultTypeInternal _SC_REGIST_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::BC_GL_CHAT* Arena::CreateMaybeMessage<::Protocol::BC_GL_CHAT>(Arena*);
template<> ::Protocol::BC_GL_ECHO* Arena::CreateMaybeMessage<::Protocol::BC_GL_ECHO>(Arena*);
template<> ::Protocol::CS_CHAT* Arena::CreateMaybeMessage<::Protocol::CS_CHAT>(Arena*);
template<> ::Protocol::CS_ECHO* Arena::CreateMaybeMessage<::Protocol::CS_ECHO>(Arena*);
template<> ::Protocol::CS_ENTER_ROOM* Arena::CreateMaybeMessage<::Protocol::CS_ENTER_ROOM>(Arena*);
template<> ::Protocol::CS_LOGIN* Arena::CreateMaybeMessage<::Protocol::CS_LOGIN>(Arena*);
template<> ::Protocol::CS_REGIST* Arena::CreateMaybeMessage<::Protocol::CS_REGIST>(Arena*);
template<> ::Protocol::SC_CHAT* Arena::CreateMaybeMessage<::Protocol::SC_CHAT>(Arena*);
template<> ::Protocol::SC_ENTER_ROOM* Arena::CreateMaybeMessage<::Protocol::SC_ENTER_ROOM>(Arena*);
template<> ::Protocol::SC_ENTER_ROOM_OTHERS* Arena::CreateMaybeMessage<::Protocol::SC_ENTER_ROOM_OTHERS>(Arena*);
template<> ::Protocol::SC_LOGIN* Arena::CreateMaybeMessage<::Protocol::SC_LOGIN>(Arena*);
template<> ::Protocol::SC_REGIST* Arena::CreateMaybeMessage<::Protocol::SC_REGIST>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class CS_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_LOGIN) */ {
 public:
  inline CS_LOGIN() : CS_LOGIN(nullptr) {}
  ~CS_LOGIN() override;
  explicit PROTOBUF_CONSTEXPR CS_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_LOGIN(const CS_LOGIN& from);
  CS_LOGIN(CS_LOGIN&& from) noexcept
    : CS_LOGIN() {
    *this = ::std::move(from);
  }

  inline CS_LOGIN& operator=(const CS_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_LOGIN& operator=(CS_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_LOGIN* internal_default_instance() {
    return reinterpret_cast<const CS_LOGIN*>(
               &_CS_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CS_LOGIN& a, CS_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_LOGIN& from) {
    CS_LOGIN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_LOGIN";
  }
  protected:
  explicit CS_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 2,
    kPasswdFieldNumber = 3,
    kBIsDevLoginFieldNumber = 1,
  };
  // string user_name = 2;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // string passwd = 3;
  void clear_passwd();
  const std::string& passwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passwd();
  PROTOBUF_NODISCARD std::string* release_passwd();
  void set_allocated_passwd(std::string* passwd);
  private:
  const std::string& _internal_passwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passwd(const std::string& value);
  std::string* _internal_mutable_passwd();
  public:

  // bool bIsDevLogin = 1;
  void clear_bisdevlogin();
  bool bisdevlogin() const;
  void set_bisdevlogin(bool value);
  private:
  bool _internal_bisdevlogin() const;
  void _internal_set_bisdevlogin(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passwd_;
    bool bisdevlogin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_LOGIN) */ {
 public:
  inline SC_LOGIN() : SC_LOGIN(nullptr) {}
  ~SC_LOGIN() override;
  explicit PROTOBUF_CONSTEXPR SC_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_LOGIN(const SC_LOGIN& from);
  SC_LOGIN(SC_LOGIN&& from) noexcept
    : SC_LOGIN() {
    *this = ::std::move(from);
  }

  inline SC_LOGIN& operator=(const SC_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_LOGIN& operator=(SC_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_LOGIN* internal_default_instance() {
    return reinterpret_cast<const SC_LOGIN*>(
               &_SC_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SC_LOGIN& a, SC_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_LOGIN& from) {
    SC_LOGIN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_LOGIN";
  }
  protected:
  explicit SC_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserInfoFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // .Protocol.hyps_user_info user_info = 3;
  bool has_user_info() const;
  private:
  bool _internal_has_user_info() const;
  public:
  void clear_user_info();
  const ::Protocol::hyps_user_info& user_info() const;
  PROTOBUF_NODISCARD ::Protocol::hyps_user_info* release_user_info();
  ::Protocol::hyps_user_info* mutable_user_info();
  void set_allocated_user_info(::Protocol::hyps_user_info* user_info);
  private:
  const ::Protocol::hyps_user_info& _internal_user_info() const;
  ::Protocol::hyps_user_info* _internal_mutable_user_info();
  public:
  void unsafe_arena_set_allocated_user_info(
      ::Protocol::hyps_user_info* user_info);
  ::Protocol::hyps_user_info* unsafe_arena_release_user_info();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::hyps_user_info* user_info_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_REGIST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_REGIST) */ {
 public:
  inline CS_REGIST() : CS_REGIST(nullptr) {}
  ~CS_REGIST() override;
  explicit PROTOBUF_CONSTEXPR CS_REGIST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_REGIST(const CS_REGIST& from);
  CS_REGIST(CS_REGIST&& from) noexcept
    : CS_REGIST() {
    *this = ::std::move(from);
  }

  inline CS_REGIST& operator=(const CS_REGIST& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_REGIST& operator=(CS_REGIST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_REGIST& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_REGIST* internal_default_instance() {
    return reinterpret_cast<const CS_REGIST*>(
               &_CS_REGIST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CS_REGIST& a, CS_REGIST& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_REGIST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_REGIST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_REGIST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_REGIST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_REGIST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_REGIST& from) {
    CS_REGIST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_REGIST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_REGIST";
  }
  protected:
  explicit CS_REGIST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
    kPasswdFieldNumber = 2,
  };
  // string user_name = 1;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // string passwd = 2;
  void clear_passwd();
  const std::string& passwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passwd();
  PROTOBUF_NODISCARD std::string* release_passwd();
  void set_allocated_passwd(std::string* passwd);
  private:
  const std::string& _internal_passwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passwd(const std::string& value);
  std::string* _internal_mutable_passwd();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_REGIST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passwd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_REGIST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_REGIST) */ {
 public:
  inline SC_REGIST() : SC_REGIST(nullptr) {}
  ~SC_REGIST() override;
  explicit PROTOBUF_CONSTEXPR SC_REGIST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_REGIST(const SC_REGIST& from);
  SC_REGIST(SC_REGIST&& from) noexcept
    : SC_REGIST() {
    *this = ::std::move(from);
  }

  inline SC_REGIST& operator=(const SC_REGIST& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_REGIST& operator=(SC_REGIST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_REGIST& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_REGIST* internal_default_instance() {
    return reinterpret_cast<const SC_REGIST*>(
               &_SC_REGIST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SC_REGIST& a, SC_REGIST& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_REGIST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_REGIST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_REGIST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_REGIST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_REGIST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_REGIST& from) {
    SC_REGIST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_REGIST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_REGIST";
  }
  protected:
  explicit SC_REGIST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string user_name = 2;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_REGIST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_ENTER_ROOM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_ENTER_ROOM) */ {
 public:
  inline CS_ENTER_ROOM() : CS_ENTER_ROOM(nullptr) {}
  ~CS_ENTER_ROOM() override;
  explicit PROTOBUF_CONSTEXPR CS_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_ENTER_ROOM(const CS_ENTER_ROOM& from);
  CS_ENTER_ROOM(CS_ENTER_ROOM&& from) noexcept
    : CS_ENTER_ROOM() {
    *this = ::std::move(from);
  }

  inline CS_ENTER_ROOM& operator=(const CS_ENTER_ROOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_ENTER_ROOM& operator=(CS_ENTER_ROOM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_ENTER_ROOM& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_ENTER_ROOM* internal_default_instance() {
    return reinterpret_cast<const CS_ENTER_ROOM*>(
               &_CS_ENTER_ROOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CS_ENTER_ROOM& a, CS_ENTER_ROOM& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_ENTER_ROOM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_ENTER_ROOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_ENTER_ROOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_ENTER_ROOM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_ENTER_ROOM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_ENTER_ROOM& from) {
    CS_ENTER_ROOM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_ENTER_ROOM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_ENTER_ROOM";
  }
  protected:
  explicit CS_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomNameFieldNumber = 1,
    kUserIdFieldNumber = 2,
  };
  // string room_name = 1;
  void clear_room_name();
  const std::string& room_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_name();
  PROTOBUF_NODISCARD std::string* release_room_name();
  void set_allocated_room_name(std::string* room_name);
  private:
  const std::string& _internal_room_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* _internal_mutable_room_name();
  public:

  // uint64 userId = 2;
  void clear_userid();
  uint64_t userid() const;
  void set_userid(uint64_t value);
  private:
  uint64_t _internal_userid() const;
  void _internal_set_userid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_ENTER_ROOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_name_;
    uint64_t userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_ENTER_ROOM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_ENTER_ROOM) */ {
 public:
  inline SC_ENTER_ROOM() : SC_ENTER_ROOM(nullptr) {}
  ~SC_ENTER_ROOM() override;
  explicit PROTOBUF_CONSTEXPR SC_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_ENTER_ROOM(const SC_ENTER_ROOM& from);
  SC_ENTER_ROOM(SC_ENTER_ROOM&& from) noexcept
    : SC_ENTER_ROOM() {
    *this = ::std::move(from);
  }

  inline SC_ENTER_ROOM& operator=(const SC_ENTER_ROOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_ENTER_ROOM& operator=(SC_ENTER_ROOM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_ENTER_ROOM& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_ENTER_ROOM* internal_default_instance() {
    return reinterpret_cast<const SC_ENTER_ROOM*>(
               &_SC_ENTER_ROOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SC_ENTER_ROOM& a, SC_ENTER_ROOM& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_ENTER_ROOM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_ENTER_ROOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_ENTER_ROOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_ENTER_ROOM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_ENTER_ROOM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_ENTER_ROOM& from) {
    SC_ENTER_ROOM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_ENTER_ROOM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_ENTER_ROOM";
  }
  protected:
  explicit SC_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated .Protocol.hyps_user_info users = 2;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::Protocol::hyps_user_info* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info >*
      mutable_users();
  private:
  const ::Protocol::hyps_user_info& _internal_users(int index) const;
  ::Protocol::hyps_user_info* _internal_add_users();
  public:
  const ::Protocol::hyps_user_info& users(int index) const;
  ::Protocol::hyps_user_info* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info >&
      users() const;

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_ENTER_ROOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info > users_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_ENTER_ROOM_OTHERS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_ENTER_ROOM_OTHERS) */ {
 public:
  inline SC_ENTER_ROOM_OTHERS() : SC_ENTER_ROOM_OTHERS(nullptr) {}
  ~SC_ENTER_ROOM_OTHERS() override;
  explicit PROTOBUF_CONSTEXPR SC_ENTER_ROOM_OTHERS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_ENTER_ROOM_OTHERS(const SC_ENTER_ROOM_OTHERS& from);
  SC_ENTER_ROOM_OTHERS(SC_ENTER_ROOM_OTHERS&& from) noexcept
    : SC_ENTER_ROOM_OTHERS() {
    *this = ::std::move(from);
  }

  inline SC_ENTER_ROOM_OTHERS& operator=(const SC_ENTER_ROOM_OTHERS& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_ENTER_ROOM_OTHERS& operator=(SC_ENTER_ROOM_OTHERS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_ENTER_ROOM_OTHERS& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_ENTER_ROOM_OTHERS* internal_default_instance() {
    return reinterpret_cast<const SC_ENTER_ROOM_OTHERS*>(
               &_SC_ENTER_ROOM_OTHERS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SC_ENTER_ROOM_OTHERS& a, SC_ENTER_ROOM_OTHERS& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_ENTER_ROOM_OTHERS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_ENTER_ROOM_OTHERS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_ENTER_ROOM_OTHERS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_ENTER_ROOM_OTHERS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_ENTER_ROOM_OTHERS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_ENTER_ROOM_OTHERS& from) {
    SC_ENTER_ROOM_OTHERS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_ENTER_ROOM_OTHERS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_ENTER_ROOM_OTHERS";
  }
  protected:
  explicit SC_ENTER_ROOM_OTHERS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated .Protocol.hyps_user_info users = 2;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::Protocol::hyps_user_info* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info >*
      mutable_users();
  private:
  const ::Protocol::hyps_user_info& _internal_users(int index) const;
  ::Protocol::hyps_user_info* _internal_add_users();
  public:
  const ::Protocol::hyps_user_info& users(int index) const;
  ::Protocol::hyps_user_info* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info >&
      users() const;

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_ENTER_ROOM_OTHERS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info > users_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_CHAT) */ {
 public:
  inline CS_CHAT() : CS_CHAT(nullptr) {}
  ~CS_CHAT() override;
  explicit PROTOBUF_CONSTEXPR CS_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_CHAT(const CS_CHAT& from);
  CS_CHAT(CS_CHAT&& from) noexcept
    : CS_CHAT() {
    *this = ::std::move(from);
  }

  inline CS_CHAT& operator=(const CS_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_CHAT& operator=(CS_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_CHAT* internal_default_instance() {
    return reinterpret_cast<const CS_CHAT*>(
               &_CS_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CS_CHAT& a, CS_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_CHAT& from) {
    CS_CHAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_CHAT";
  }
  protected:
  explicit CS_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_CHAT) */ {
 public:
  inline SC_CHAT() : SC_CHAT(nullptr) {}
  ~SC_CHAT() override;
  explicit PROTOBUF_CONSTEXPR SC_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_CHAT(const SC_CHAT& from);
  SC_CHAT(SC_CHAT&& from) noexcept
    : SC_CHAT() {
    *this = ::std::move(from);
  }

  inline SC_CHAT& operator=(const SC_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_CHAT& operator=(SC_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_CHAT* internal_default_instance() {
    return reinterpret_cast<const SC_CHAT*>(
               &_SC_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SC_CHAT& a, SC_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_CHAT& from) {
    SC_CHAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_CHAT";
  }
  protected:
  explicit SC_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 3,
    kUserIdFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 3;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // uint64 userId = 2;
  void clear_userid();
  uint64_t userid() const;
  void set_userid(uint64_t value);
  private:
  uint64_t _internal_userid() const;
  void _internal_set_userid(uint64_t value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    uint64_t userid_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class BC_GL_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.BC_GL_CHAT) */ {
 public:
  inline BC_GL_CHAT() : BC_GL_CHAT(nullptr) {}
  ~BC_GL_CHAT() override;
  explicit PROTOBUF_CONSTEXPR BC_GL_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BC_GL_CHAT(const BC_GL_CHAT& from);
  BC_GL_CHAT(BC_GL_CHAT&& from) noexcept
    : BC_GL_CHAT() {
    *this = ::std::move(from);
  }

  inline BC_GL_CHAT& operator=(const BC_GL_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline BC_GL_CHAT& operator=(BC_GL_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BC_GL_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const BC_GL_CHAT* internal_default_instance() {
    return reinterpret_cast<const BC_GL_CHAT*>(
               &_BC_GL_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BC_GL_CHAT& a, BC_GL_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(BC_GL_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BC_GL_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BC_GL_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BC_GL_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BC_GL_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BC_GL_CHAT& from) {
    BC_GL_CHAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BC_GL_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.BC_GL_CHAT";
  }
  protected:
  explicit BC_GL_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.BC_GL_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_ECHO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_ECHO) */ {
 public:
  inline CS_ECHO() : CS_ECHO(nullptr) {}
  ~CS_ECHO() override;
  explicit PROTOBUF_CONSTEXPR CS_ECHO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_ECHO(const CS_ECHO& from);
  CS_ECHO(CS_ECHO&& from) noexcept
    : CS_ECHO() {
    *this = ::std::move(from);
  }

  inline CS_ECHO& operator=(const CS_ECHO& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_ECHO& operator=(CS_ECHO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_ECHO& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_ECHO* internal_default_instance() {
    return reinterpret_cast<const CS_ECHO*>(
               &_CS_ECHO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CS_ECHO& a, CS_ECHO& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_ECHO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_ECHO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_ECHO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_ECHO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_ECHO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_ECHO& from) {
    CS_ECHO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_ECHO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_ECHO";
  }
  protected:
  explicit CS_ECHO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_ECHO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class BC_GL_ECHO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.BC_GL_ECHO) */ {
 public:
  inline BC_GL_ECHO() : BC_GL_ECHO(nullptr) {}
  ~BC_GL_ECHO() override;
  explicit PROTOBUF_CONSTEXPR BC_GL_ECHO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BC_GL_ECHO(const BC_GL_ECHO& from);
  BC_GL_ECHO(BC_GL_ECHO&& from) noexcept
    : BC_GL_ECHO() {
    *this = ::std::move(from);
  }

  inline BC_GL_ECHO& operator=(const BC_GL_ECHO& from) {
    CopyFrom(from);
    return *this;
  }
  inline BC_GL_ECHO& operator=(BC_GL_ECHO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BC_GL_ECHO& default_instance() {
    return *internal_default_instance();
  }
  static inline const BC_GL_ECHO* internal_default_instance() {
    return reinterpret_cast<const BC_GL_ECHO*>(
               &_BC_GL_ECHO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BC_GL_ECHO& a, BC_GL_ECHO& b) {
    a.Swap(&b);
  }
  inline void Swap(BC_GL_ECHO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BC_GL_ECHO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BC_GL_ECHO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BC_GL_ECHO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BC_GL_ECHO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BC_GL_ECHO& from) {
    BC_GL_ECHO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BC_GL_ECHO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.BC_GL_ECHO";
  }
  protected:
  explicit BC_GL_ECHO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.BC_GL_ECHO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CS_LOGIN

// bool bIsDevLogin = 1;
inline void CS_LOGIN::clear_bisdevlogin() {
  _impl_.bisdevlogin_ = false;
}
inline bool CS_LOGIN::_internal_bisdevlogin() const {
  return _impl_.bisdevlogin_;
}
inline bool CS_LOGIN::bisdevlogin() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_LOGIN.bIsDevLogin)
  return _internal_bisdevlogin();
}
inline void CS_LOGIN::_internal_set_bisdevlogin(bool value) {
  
  _impl_.bisdevlogin_ = value;
}
inline void CS_LOGIN::set_bisdevlogin(bool value) {
  _internal_set_bisdevlogin(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_LOGIN.bIsDevLogin)
}

// string user_name = 2;
inline void CS_LOGIN::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& CS_LOGIN::user_name() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_LOGIN.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_LOGIN::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CS_LOGIN.user_name)
}
inline std::string* CS_LOGIN::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_LOGIN.user_name)
  return _s;
}
inline const std::string& CS_LOGIN::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void CS_LOGIN::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_LOGIN::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_LOGIN::release_user_name() {
  // @@protoc_insertion_point(field_release:Protocol.CS_LOGIN.user_name)
  return _impl_.user_name_.Release();
}
inline void CS_LOGIN::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_LOGIN.user_name)
}

// string passwd = 3;
inline void CS_LOGIN::clear_passwd() {
  _impl_.passwd_.ClearToEmpty();
}
inline const std::string& CS_LOGIN::passwd() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_LOGIN.passwd)
  return _internal_passwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_LOGIN::set_passwd(ArgT0&& arg0, ArgT... args) {
 
 _impl_.passwd_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CS_LOGIN.passwd)
}
inline std::string* CS_LOGIN::mutable_passwd() {
  std::string* _s = _internal_mutable_passwd();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_LOGIN.passwd)
  return _s;
}
inline const std::string& CS_LOGIN::_internal_passwd() const {
  return _impl_.passwd_.Get();
}
inline void CS_LOGIN::_internal_set_passwd(const std::string& value) {
  
  _impl_.passwd_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_LOGIN::_internal_mutable_passwd() {
  
  return _impl_.passwd_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_LOGIN::release_passwd() {
  // @@protoc_insertion_point(field_release:Protocol.CS_LOGIN.passwd)
  return _impl_.passwd_.Release();
}
inline void CS_LOGIN::set_allocated_passwd(std::string* passwd) {
  if (passwd != nullptr) {
    
  } else {
    
  }
  _impl_.passwd_.SetAllocated(passwd, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.passwd_.IsDefault()) {
    _impl_.passwd_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_LOGIN.passwd)
}

// -------------------------------------------------------------------

// SC_LOGIN

// bool success = 1;
inline void SC_LOGIN::clear_success() {
  _impl_.success_ = false;
}
inline bool SC_LOGIN::_internal_success() const {
  return _impl_.success_;
}
inline bool SC_LOGIN::success() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_LOGIN.success)
  return _internal_success();
}
inline void SC_LOGIN::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void SC_LOGIN::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_LOGIN.success)
}

// .Protocol.hyps_user_info user_info = 3;
inline bool SC_LOGIN::_internal_has_user_info() const {
  return this != internal_default_instance() && _impl_.user_info_ != nullptr;
}
inline bool SC_LOGIN::has_user_info() const {
  return _internal_has_user_info();
}
inline const ::Protocol::hyps_user_info& SC_LOGIN::_internal_user_info() const {
  const ::Protocol::hyps_user_info* p = _impl_.user_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::hyps_user_info&>(
      ::Protocol::_hyps_user_info_default_instance_);
}
inline const ::Protocol::hyps_user_info& SC_LOGIN::user_info() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_LOGIN.user_info)
  return _internal_user_info();
}
inline void SC_LOGIN::unsafe_arena_set_allocated_user_info(
    ::Protocol::hyps_user_info* user_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_info_);
  }
  _impl_.user_info_ = user_info;
  if (user_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.SC_LOGIN.user_info)
}
inline ::Protocol::hyps_user_info* SC_LOGIN::release_user_info() {
  
  ::Protocol::hyps_user_info* temp = _impl_.user_info_;
  _impl_.user_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::hyps_user_info* SC_LOGIN::unsafe_arena_release_user_info() {
  // @@protoc_insertion_point(field_release:Protocol.SC_LOGIN.user_info)
  
  ::Protocol::hyps_user_info* temp = _impl_.user_info_;
  _impl_.user_info_ = nullptr;
  return temp;
}
inline ::Protocol::hyps_user_info* SC_LOGIN::_internal_mutable_user_info() {
  
  if (_impl_.user_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::hyps_user_info>(GetArenaForAllocation());
    _impl_.user_info_ = p;
  }
  return _impl_.user_info_;
}
inline ::Protocol::hyps_user_info* SC_LOGIN::mutable_user_info() {
  ::Protocol::hyps_user_info* _msg = _internal_mutable_user_info();
  // @@protoc_insertion_point(field_mutable:Protocol.SC_LOGIN.user_info)
  return _msg;
}
inline void SC_LOGIN::set_allocated_user_info(::Protocol::hyps_user_info* user_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_info_);
  }
  if (user_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_info));
    if (message_arena != submessage_arena) {
      user_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_info_ = user_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.SC_LOGIN.user_info)
}

// -------------------------------------------------------------------

// CS_REGIST

// string user_name = 1;
inline void CS_REGIST::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& CS_REGIST::user_name() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_REGIST.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_REGIST::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CS_REGIST.user_name)
}
inline std::string* CS_REGIST::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_REGIST.user_name)
  return _s;
}
inline const std::string& CS_REGIST::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void CS_REGIST::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_REGIST::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_REGIST::release_user_name() {
  // @@protoc_insertion_point(field_release:Protocol.CS_REGIST.user_name)
  return _impl_.user_name_.Release();
}
inline void CS_REGIST::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_REGIST.user_name)
}

// string passwd = 2;
inline void CS_REGIST::clear_passwd() {
  _impl_.passwd_.ClearToEmpty();
}
inline const std::string& CS_REGIST::passwd() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_REGIST.passwd)
  return _internal_passwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_REGIST::set_passwd(ArgT0&& arg0, ArgT... args) {
 
 _impl_.passwd_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CS_REGIST.passwd)
}
inline std::string* CS_REGIST::mutable_passwd() {
  std::string* _s = _internal_mutable_passwd();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_REGIST.passwd)
  return _s;
}
inline const std::string& CS_REGIST::_internal_passwd() const {
  return _impl_.passwd_.Get();
}
inline void CS_REGIST::_internal_set_passwd(const std::string& value) {
  
  _impl_.passwd_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_REGIST::_internal_mutable_passwd() {
  
  return _impl_.passwd_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_REGIST::release_passwd() {
  // @@protoc_insertion_point(field_release:Protocol.CS_REGIST.passwd)
  return _impl_.passwd_.Release();
}
inline void CS_REGIST::set_allocated_passwd(std::string* passwd) {
  if (passwd != nullptr) {
    
  } else {
    
  }
  _impl_.passwd_.SetAllocated(passwd, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.passwd_.IsDefault()) {
    _impl_.passwd_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_REGIST.passwd)
}

// -------------------------------------------------------------------

// SC_REGIST

// bool success = 1;
inline void SC_REGIST::clear_success() {
  _impl_.success_ = false;
}
inline bool SC_REGIST::_internal_success() const {
  return _impl_.success_;
}
inline bool SC_REGIST::success() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_REGIST.success)
  return _internal_success();
}
inline void SC_REGIST::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void SC_REGIST::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_REGIST.success)
}

// string user_name = 2;
inline void SC_REGIST::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& SC_REGIST::user_name() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_REGIST.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SC_REGIST::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.SC_REGIST.user_name)
}
inline std::string* SC_REGIST::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:Protocol.SC_REGIST.user_name)
  return _s;
}
inline const std::string& SC_REGIST::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void SC_REGIST::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SC_REGIST::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SC_REGIST::release_user_name() {
  // @@protoc_insertion_point(field_release:Protocol.SC_REGIST.user_name)
  return _impl_.user_name_.Release();
}
inline void SC_REGIST::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.SC_REGIST.user_name)
}

// -------------------------------------------------------------------

// CS_ENTER_ROOM

// string room_name = 1;
inline void CS_ENTER_ROOM::clear_room_name() {
  _impl_.room_name_.ClearToEmpty();
}
inline const std::string& CS_ENTER_ROOM::room_name() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_ENTER_ROOM.room_name)
  return _internal_room_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_ENTER_ROOM::set_room_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CS_ENTER_ROOM.room_name)
}
inline std::string* CS_ENTER_ROOM::mutable_room_name() {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_ENTER_ROOM.room_name)
  return _s;
}
inline const std::string& CS_ENTER_ROOM::_internal_room_name() const {
  return _impl_.room_name_.Get();
}
inline void CS_ENTER_ROOM::_internal_set_room_name(const std::string& value) {
  
  _impl_.room_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_ENTER_ROOM::_internal_mutable_room_name() {
  
  return _impl_.room_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_ENTER_ROOM::release_room_name() {
  // @@protoc_insertion_point(field_release:Protocol.CS_ENTER_ROOM.room_name)
  return _impl_.room_name_.Release();
}
inline void CS_ENTER_ROOM::set_allocated_room_name(std::string* room_name) {
  if (room_name != nullptr) {
    
  } else {
    
  }
  _impl_.room_name_.SetAllocated(room_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_ENTER_ROOM.room_name)
}

// uint64 userId = 2;
inline void CS_ENTER_ROOM::clear_userid() {
  _impl_.userid_ = uint64_t{0u};
}
inline uint64_t CS_ENTER_ROOM::_internal_userid() const {
  return _impl_.userid_;
}
inline uint64_t CS_ENTER_ROOM::userid() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_ENTER_ROOM.userId)
  return _internal_userid();
}
inline void CS_ENTER_ROOM::_internal_set_userid(uint64_t value) {
  
  _impl_.userid_ = value;
}
inline void CS_ENTER_ROOM::set_userid(uint64_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_ENTER_ROOM.userId)
}

// -------------------------------------------------------------------

// SC_ENTER_ROOM

// bool success = 1;
inline void SC_ENTER_ROOM::clear_success() {
  _impl_.success_ = false;
}
inline bool SC_ENTER_ROOM::_internal_success() const {
  return _impl_.success_;
}
inline bool SC_ENTER_ROOM::success() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_ENTER_ROOM.success)
  return _internal_success();
}
inline void SC_ENTER_ROOM::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void SC_ENTER_ROOM::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_ENTER_ROOM.success)
}

// repeated .Protocol.hyps_user_info users = 2;
inline int SC_ENTER_ROOM::_internal_users_size() const {
  return _impl_.users_.size();
}
inline int SC_ENTER_ROOM::users_size() const {
  return _internal_users_size();
}
inline ::Protocol::hyps_user_info* SC_ENTER_ROOM::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.SC_ENTER_ROOM.users)
  return _impl_.users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info >*
SC_ENTER_ROOM::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.SC_ENTER_ROOM.users)
  return &_impl_.users_;
}
inline const ::Protocol::hyps_user_info& SC_ENTER_ROOM::_internal_users(int index) const {
  return _impl_.users_.Get(index);
}
inline const ::Protocol::hyps_user_info& SC_ENTER_ROOM::users(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.SC_ENTER_ROOM.users)
  return _internal_users(index);
}
inline ::Protocol::hyps_user_info* SC_ENTER_ROOM::_internal_add_users() {
  return _impl_.users_.Add();
}
inline ::Protocol::hyps_user_info* SC_ENTER_ROOM::add_users() {
  ::Protocol::hyps_user_info* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:Protocol.SC_ENTER_ROOM.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info >&
SC_ENTER_ROOM::users() const {
  // @@protoc_insertion_point(field_list:Protocol.SC_ENTER_ROOM.users)
  return _impl_.users_;
}

// -------------------------------------------------------------------

// SC_ENTER_ROOM_OTHERS

// bool success = 1;
inline void SC_ENTER_ROOM_OTHERS::clear_success() {
  _impl_.success_ = false;
}
inline bool SC_ENTER_ROOM_OTHERS::_internal_success() const {
  return _impl_.success_;
}
inline bool SC_ENTER_ROOM_OTHERS::success() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_ENTER_ROOM_OTHERS.success)
  return _internal_success();
}
inline void SC_ENTER_ROOM_OTHERS::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void SC_ENTER_ROOM_OTHERS::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_ENTER_ROOM_OTHERS.success)
}

// repeated .Protocol.hyps_user_info users = 2;
inline int SC_ENTER_ROOM_OTHERS::_internal_users_size() const {
  return _impl_.users_.size();
}
inline int SC_ENTER_ROOM_OTHERS::users_size() const {
  return _internal_users_size();
}
inline ::Protocol::hyps_user_info* SC_ENTER_ROOM_OTHERS::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.SC_ENTER_ROOM_OTHERS.users)
  return _impl_.users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info >*
SC_ENTER_ROOM_OTHERS::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.SC_ENTER_ROOM_OTHERS.users)
  return &_impl_.users_;
}
inline const ::Protocol::hyps_user_info& SC_ENTER_ROOM_OTHERS::_internal_users(int index) const {
  return _impl_.users_.Get(index);
}
inline const ::Protocol::hyps_user_info& SC_ENTER_ROOM_OTHERS::users(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.SC_ENTER_ROOM_OTHERS.users)
  return _internal_users(index);
}
inline ::Protocol::hyps_user_info* SC_ENTER_ROOM_OTHERS::_internal_add_users() {
  return _impl_.users_.Add();
}
inline ::Protocol::hyps_user_info* SC_ENTER_ROOM_OTHERS::add_users() {
  ::Protocol::hyps_user_info* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:Protocol.SC_ENTER_ROOM_OTHERS.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info >&
SC_ENTER_ROOM_OTHERS::users() const {
  // @@protoc_insertion_point(field_list:Protocol.SC_ENTER_ROOM_OTHERS.users)
  return _impl_.users_;
}

// -------------------------------------------------------------------

// CS_CHAT

// string msg = 1;
inline void CS_CHAT::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& CS_CHAT::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_CHAT.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_CHAT::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CS_CHAT.msg)
}
inline std::string* CS_CHAT::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_CHAT.msg)
  return _s;
}
inline const std::string& CS_CHAT::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void CS_CHAT::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_CHAT::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_CHAT::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.CS_CHAT.msg)
  return _impl_.msg_.Release();
}
inline void CS_CHAT::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_CHAT.msg)
}

// -------------------------------------------------------------------

// SC_CHAT

// bool success = 1;
inline void SC_CHAT::clear_success() {
  _impl_.success_ = false;
}
inline bool SC_CHAT::_internal_success() const {
  return _impl_.success_;
}
inline bool SC_CHAT::success() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_CHAT.success)
  return _internal_success();
}
inline void SC_CHAT::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void SC_CHAT::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_CHAT.success)
}

// uint64 userId = 2;
inline void SC_CHAT::clear_userid() {
  _impl_.userid_ = uint64_t{0u};
}
inline uint64_t SC_CHAT::_internal_userid() const {
  return _impl_.userid_;
}
inline uint64_t SC_CHAT::userid() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_CHAT.userId)
  return _internal_userid();
}
inline void SC_CHAT::_internal_set_userid(uint64_t value) {
  
  _impl_.userid_ = value;
}
inline void SC_CHAT::set_userid(uint64_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_CHAT.userId)
}

// string msg = 3;
inline void SC_CHAT::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& SC_CHAT::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_CHAT.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SC_CHAT::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.SC_CHAT.msg)
}
inline std::string* SC_CHAT::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Protocol.SC_CHAT.msg)
  return _s;
}
inline const std::string& SC_CHAT::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void SC_CHAT::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* SC_CHAT::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* SC_CHAT::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.SC_CHAT.msg)
  return _impl_.msg_.Release();
}
inline void SC_CHAT::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.SC_CHAT.msg)
}

// -------------------------------------------------------------------

// BC_GL_CHAT

// string msg = 1;
inline void BC_GL_CHAT::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& BC_GL_CHAT::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.BC_GL_CHAT.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BC_GL_CHAT::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.BC_GL_CHAT.msg)
}
inline std::string* BC_GL_CHAT::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Protocol.BC_GL_CHAT.msg)
  return _s;
}
inline const std::string& BC_GL_CHAT::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void BC_GL_CHAT::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* BC_GL_CHAT::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* BC_GL_CHAT::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.BC_GL_CHAT.msg)
  return _impl_.msg_.Release();
}
inline void BC_GL_CHAT::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.BC_GL_CHAT.msg)
}

// -------------------------------------------------------------------

// CS_ECHO

// string msg = 1;
inline void CS_ECHO::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& CS_ECHO::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_ECHO.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_ECHO::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CS_ECHO.msg)
}
inline std::string* CS_ECHO::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_ECHO.msg)
  return _s;
}
inline const std::string& CS_ECHO::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void CS_ECHO::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_ECHO::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_ECHO::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.CS_ECHO.msg)
  return _impl_.msg_.Release();
}
inline void CS_ECHO::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_ECHO.msg)
}

// -------------------------------------------------------------------

// BC_GL_ECHO

// string msg = 1;
inline void BC_GL_ECHO::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& BC_GL_ECHO::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.BC_GL_ECHO.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BC_GL_ECHO::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.BC_GL_ECHO.msg)
}
inline std::string* BC_GL_ECHO::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Protocol.BC_GL_ECHO.msg)
  return _s;
}
inline const std::string& BC_GL_ECHO::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void BC_GL_ECHO::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* BC_GL_ECHO::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* BC_GL_ECHO::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.BC_GL_ECHO.msg)
  return _impl_.msg_.Release();
}
inline void BC_GL_ECHO::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.BC_GL_ECHO.msg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
