// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
#include "Struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class BC_DESPAWN;
struct BC_DESPAWNDefaultTypeInternal;
extern BC_DESPAWNDefaultTypeInternal _BC_DESPAWN_default_instance_;
class BC_ENTER_ROOM_OTHERS;
struct BC_ENTER_ROOM_OTHERSDefaultTypeInternal;
extern BC_ENTER_ROOM_OTHERSDefaultTypeInternal _BC_ENTER_ROOM_OTHERS_default_instance_;
class BC_GL_CHAT;
struct BC_GL_CHATDefaultTypeInternal;
extern BC_GL_CHATDefaultTypeInternal _BC_GL_CHAT_default_instance_;
class BC_GL_ECHO;
struct BC_GL_ECHODefaultTypeInternal;
extern BC_GL_ECHODefaultTypeInternal _BC_GL_ECHO_default_instance_;
class BC_LEAVE_GAME;
struct BC_LEAVE_GAMEDefaultTypeInternal;
extern BC_LEAVE_GAMEDefaultTypeInternal _BC_LEAVE_GAME_default_instance_;
class BC_SPAWN;
struct BC_SPAWNDefaultTypeInternal;
extern BC_SPAWNDefaultTypeInternal _BC_SPAWN_default_instance_;
class CS_CHAT;
struct CS_CHATDefaultTypeInternal;
extern CS_CHATDefaultTypeInternal _CS_CHAT_default_instance_;
class CS_ECHO;
struct CS_ECHODefaultTypeInternal;
extern CS_ECHODefaultTypeInternal _CS_ECHO_default_instance_;
class CS_ENTER_GAME;
struct CS_ENTER_GAMEDefaultTypeInternal;
extern CS_ENTER_GAMEDefaultTypeInternal _CS_ENTER_GAME_default_instance_;
class CS_ENTER_ROOM;
struct CS_ENTER_ROOMDefaultTypeInternal;
extern CS_ENTER_ROOMDefaultTypeInternal _CS_ENTER_ROOM_default_instance_;
class CS_LEAVE_GAME;
struct CS_LEAVE_GAMEDefaultTypeInternal;
extern CS_LEAVE_GAMEDefaultTypeInternal _CS_LEAVE_GAME_default_instance_;
class CS_LOGIN;
struct CS_LOGINDefaultTypeInternal;
extern CS_LOGINDefaultTypeInternal _CS_LOGIN_default_instance_;
class CS_MOVE_OBJECT;
struct CS_MOVE_OBJECTDefaultTypeInternal;
extern CS_MOVE_OBJECTDefaultTypeInternal _CS_MOVE_OBJECT_default_instance_;
class CS_REGIST;
struct CS_REGISTDefaultTypeInternal;
extern CS_REGISTDefaultTypeInternal _CS_REGIST_default_instance_;
class SC_CHAT;
struct SC_CHATDefaultTypeInternal;
extern SC_CHATDefaultTypeInternal _SC_CHAT_default_instance_;
class SC_DESPAWN;
struct SC_DESPAWNDefaultTypeInternal;
extern SC_DESPAWNDefaultTypeInternal _SC_DESPAWN_default_instance_;
class SC_ENTER_GAME;
struct SC_ENTER_GAMEDefaultTypeInternal;
extern SC_ENTER_GAMEDefaultTypeInternal _SC_ENTER_GAME_default_instance_;
class SC_ENTER_ROOM;
struct SC_ENTER_ROOMDefaultTypeInternal;
extern SC_ENTER_ROOMDefaultTypeInternal _SC_ENTER_ROOM_default_instance_;
class SC_LEAVE_GAME;
struct SC_LEAVE_GAMEDefaultTypeInternal;
extern SC_LEAVE_GAMEDefaultTypeInternal _SC_LEAVE_GAME_default_instance_;
class SC_LOGIN;
struct SC_LOGINDefaultTypeInternal;
extern SC_LOGINDefaultTypeInternal _SC_LOGIN_default_instance_;
class SC_MOVE_OBJECT;
struct SC_MOVE_OBJECTDefaultTypeInternal;
extern SC_MOVE_OBJECTDefaultTypeInternal _SC_MOVE_OBJECT_default_instance_;
class SC_REGIST;
struct SC_REGISTDefaultTypeInternal;
extern SC_REGISTDefaultTypeInternal _SC_REGIST_default_instance_;
class SC_SPAWN;
struct SC_SPAWNDefaultTypeInternal;
extern SC_SPAWNDefaultTypeInternal _SC_SPAWN_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::BC_DESPAWN* Arena::CreateMaybeMessage<::Protocol::BC_DESPAWN>(Arena*);
template<> ::Protocol::BC_ENTER_ROOM_OTHERS* Arena::CreateMaybeMessage<::Protocol::BC_ENTER_ROOM_OTHERS>(Arena*);
template<> ::Protocol::BC_GL_CHAT* Arena::CreateMaybeMessage<::Protocol::BC_GL_CHAT>(Arena*);
template<> ::Protocol::BC_GL_ECHO* Arena::CreateMaybeMessage<::Protocol::BC_GL_ECHO>(Arena*);
template<> ::Protocol::BC_LEAVE_GAME* Arena::CreateMaybeMessage<::Protocol::BC_LEAVE_GAME>(Arena*);
template<> ::Protocol::BC_SPAWN* Arena::CreateMaybeMessage<::Protocol::BC_SPAWN>(Arena*);
template<> ::Protocol::CS_CHAT* Arena::CreateMaybeMessage<::Protocol::CS_CHAT>(Arena*);
template<> ::Protocol::CS_ECHO* Arena::CreateMaybeMessage<::Protocol::CS_ECHO>(Arena*);
template<> ::Protocol::CS_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::CS_ENTER_GAME>(Arena*);
template<> ::Protocol::CS_ENTER_ROOM* Arena::CreateMaybeMessage<::Protocol::CS_ENTER_ROOM>(Arena*);
template<> ::Protocol::CS_LEAVE_GAME* Arena::CreateMaybeMessage<::Protocol::CS_LEAVE_GAME>(Arena*);
template<> ::Protocol::CS_LOGIN* Arena::CreateMaybeMessage<::Protocol::CS_LOGIN>(Arena*);
template<> ::Protocol::CS_MOVE_OBJECT* Arena::CreateMaybeMessage<::Protocol::CS_MOVE_OBJECT>(Arena*);
template<> ::Protocol::CS_REGIST* Arena::CreateMaybeMessage<::Protocol::CS_REGIST>(Arena*);
template<> ::Protocol::SC_CHAT* Arena::CreateMaybeMessage<::Protocol::SC_CHAT>(Arena*);
template<> ::Protocol::SC_DESPAWN* Arena::CreateMaybeMessage<::Protocol::SC_DESPAWN>(Arena*);
template<> ::Protocol::SC_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::SC_ENTER_GAME>(Arena*);
template<> ::Protocol::SC_ENTER_ROOM* Arena::CreateMaybeMessage<::Protocol::SC_ENTER_ROOM>(Arena*);
template<> ::Protocol::SC_LEAVE_GAME* Arena::CreateMaybeMessage<::Protocol::SC_LEAVE_GAME>(Arena*);
template<> ::Protocol::SC_LOGIN* Arena::CreateMaybeMessage<::Protocol::SC_LOGIN>(Arena*);
template<> ::Protocol::SC_MOVE_OBJECT* Arena::CreateMaybeMessage<::Protocol::SC_MOVE_OBJECT>(Arena*);
template<> ::Protocol::SC_REGIST* Arena::CreateMaybeMessage<::Protocol::SC_REGIST>(Arena*);
template<> ::Protocol::SC_SPAWN* Arena::CreateMaybeMessage<::Protocol::SC_SPAWN>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class CS_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_LOGIN) */ {
 public:
  inline CS_LOGIN() : CS_LOGIN(nullptr) {}
  ~CS_LOGIN() override;
  explicit PROTOBUF_CONSTEXPR CS_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_LOGIN(const CS_LOGIN& from);
  CS_LOGIN(CS_LOGIN&& from) noexcept
    : CS_LOGIN() {
    *this = ::std::move(from);
  }

  inline CS_LOGIN& operator=(const CS_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_LOGIN& operator=(CS_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_LOGIN* internal_default_instance() {
    return reinterpret_cast<const CS_LOGIN*>(
               &_CS_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CS_LOGIN& a, CS_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_LOGIN& from) {
    CS_LOGIN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_LOGIN";
  }
  protected:
  explicit CS_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 2,
    kPasswdFieldNumber = 3,
    kBIsDevLoginFieldNumber = 1,
  };
  // string user_name = 2;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // string passwd = 3;
  void clear_passwd();
  const std::string& passwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passwd();
  PROTOBUF_NODISCARD std::string* release_passwd();
  void set_allocated_passwd(std::string* passwd);
  private:
  const std::string& _internal_passwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passwd(const std::string& value);
  std::string* _internal_mutable_passwd();
  public:

  // bool bIsDevLogin = 1;
  void clear_bisdevlogin();
  bool bisdevlogin() const;
  void set_bisdevlogin(bool value);
  private:
  bool _internal_bisdevlogin() const;
  void _internal_set_bisdevlogin(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passwd_;
    bool bisdevlogin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_LOGIN) */ {
 public:
  inline SC_LOGIN() : SC_LOGIN(nullptr) {}
  ~SC_LOGIN() override;
  explicit PROTOBUF_CONSTEXPR SC_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_LOGIN(const SC_LOGIN& from);
  SC_LOGIN(SC_LOGIN&& from) noexcept
    : SC_LOGIN() {
    *this = ::std::move(from);
  }

  inline SC_LOGIN& operator=(const SC_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_LOGIN& operator=(SC_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_LOGIN* internal_default_instance() {
    return reinterpret_cast<const SC_LOGIN*>(
               &_SC_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SC_LOGIN& a, SC_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_LOGIN& from) {
    SC_LOGIN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_LOGIN";
  }
  protected:
  explicit SC_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 3,
    kUserInfoFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated .Protocol.hyps_pos_info players = 3;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Protocol::hyps_pos_info* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_pos_info >*
      mutable_players();
  private:
  const ::Protocol::hyps_pos_info& _internal_players(int index) const;
  ::Protocol::hyps_pos_info* _internal_add_players();
  public:
  const ::Protocol::hyps_pos_info& players(int index) const;
  ::Protocol::hyps_pos_info* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_pos_info >&
      players() const;

  // .Protocol.hyps_user_info user_info = 2;
  bool has_user_info() const;
  private:
  bool _internal_has_user_info() const;
  public:
  void clear_user_info();
  const ::Protocol::hyps_user_info& user_info() const;
  PROTOBUF_NODISCARD ::Protocol::hyps_user_info* release_user_info();
  ::Protocol::hyps_user_info* mutable_user_info();
  void set_allocated_user_info(::Protocol::hyps_user_info* user_info);
  private:
  const ::Protocol::hyps_user_info& _internal_user_info() const;
  ::Protocol::hyps_user_info* _internal_mutable_user_info();
  public:
  void unsafe_arena_set_allocated_user_info(
      ::Protocol::hyps_user_info* user_info);
  ::Protocol::hyps_user_info* unsafe_arena_release_user_info();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_pos_info > players_;
    ::Protocol::hyps_user_info* user_info_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_REGIST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_REGIST) */ {
 public:
  inline CS_REGIST() : CS_REGIST(nullptr) {}
  ~CS_REGIST() override;
  explicit PROTOBUF_CONSTEXPR CS_REGIST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_REGIST(const CS_REGIST& from);
  CS_REGIST(CS_REGIST&& from) noexcept
    : CS_REGIST() {
    *this = ::std::move(from);
  }

  inline CS_REGIST& operator=(const CS_REGIST& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_REGIST& operator=(CS_REGIST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_REGIST& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_REGIST* internal_default_instance() {
    return reinterpret_cast<const CS_REGIST*>(
               &_CS_REGIST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CS_REGIST& a, CS_REGIST& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_REGIST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_REGIST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_REGIST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_REGIST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_REGIST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_REGIST& from) {
    CS_REGIST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_REGIST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_REGIST";
  }
  protected:
  explicit CS_REGIST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
    kPasswdFieldNumber = 2,
  };
  // string user_name = 1;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // string passwd = 2;
  void clear_passwd();
  const std::string& passwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passwd();
  PROTOBUF_NODISCARD std::string* release_passwd();
  void set_allocated_passwd(std::string* passwd);
  private:
  const std::string& _internal_passwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passwd(const std::string& value);
  std::string* _internal_mutable_passwd();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_REGIST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passwd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_REGIST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_REGIST) */ {
 public:
  inline SC_REGIST() : SC_REGIST(nullptr) {}
  ~SC_REGIST() override;
  explicit PROTOBUF_CONSTEXPR SC_REGIST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_REGIST(const SC_REGIST& from);
  SC_REGIST(SC_REGIST&& from) noexcept
    : SC_REGIST() {
    *this = ::std::move(from);
  }

  inline SC_REGIST& operator=(const SC_REGIST& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_REGIST& operator=(SC_REGIST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_REGIST& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_REGIST* internal_default_instance() {
    return reinterpret_cast<const SC_REGIST*>(
               &_SC_REGIST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SC_REGIST& a, SC_REGIST& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_REGIST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_REGIST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_REGIST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_REGIST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_REGIST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_REGIST& from) {
    SC_REGIST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_REGIST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_REGIST";
  }
  protected:
  explicit SC_REGIST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string user_name = 2;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_REGIST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_ENTER_ROOM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_ENTER_ROOM) */ {
 public:
  inline CS_ENTER_ROOM() : CS_ENTER_ROOM(nullptr) {}
  ~CS_ENTER_ROOM() override;
  explicit PROTOBUF_CONSTEXPR CS_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_ENTER_ROOM(const CS_ENTER_ROOM& from);
  CS_ENTER_ROOM(CS_ENTER_ROOM&& from) noexcept
    : CS_ENTER_ROOM() {
    *this = ::std::move(from);
  }

  inline CS_ENTER_ROOM& operator=(const CS_ENTER_ROOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_ENTER_ROOM& operator=(CS_ENTER_ROOM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_ENTER_ROOM& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_ENTER_ROOM* internal_default_instance() {
    return reinterpret_cast<const CS_ENTER_ROOM*>(
               &_CS_ENTER_ROOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CS_ENTER_ROOM& a, CS_ENTER_ROOM& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_ENTER_ROOM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_ENTER_ROOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_ENTER_ROOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_ENTER_ROOM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_ENTER_ROOM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_ENTER_ROOM& from) {
    CS_ENTER_ROOM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_ENTER_ROOM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_ENTER_ROOM";
  }
  protected:
  explicit CS_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomNameFieldNumber = 1,
    kUserIdFieldNumber = 2,
  };
  // string room_name = 1;
  void clear_room_name();
  const std::string& room_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_name();
  PROTOBUF_NODISCARD std::string* release_room_name();
  void set_allocated_room_name(std::string* room_name);
  private:
  const std::string& _internal_room_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* _internal_mutable_room_name();
  public:

  // uint64 userId = 2;
  void clear_userid();
  uint64_t userid() const;
  void set_userid(uint64_t value);
  private:
  uint64_t _internal_userid() const;
  void _internal_set_userid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_ENTER_ROOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_name_;
    uint64_t userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_ENTER_ROOM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_ENTER_ROOM) */ {
 public:
  inline SC_ENTER_ROOM() : SC_ENTER_ROOM(nullptr) {}
  ~SC_ENTER_ROOM() override;
  explicit PROTOBUF_CONSTEXPR SC_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_ENTER_ROOM(const SC_ENTER_ROOM& from);
  SC_ENTER_ROOM(SC_ENTER_ROOM&& from) noexcept
    : SC_ENTER_ROOM() {
    *this = ::std::move(from);
  }

  inline SC_ENTER_ROOM& operator=(const SC_ENTER_ROOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_ENTER_ROOM& operator=(SC_ENTER_ROOM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_ENTER_ROOM& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_ENTER_ROOM* internal_default_instance() {
    return reinterpret_cast<const SC_ENTER_ROOM*>(
               &_SC_ENTER_ROOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SC_ENTER_ROOM& a, SC_ENTER_ROOM& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_ENTER_ROOM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_ENTER_ROOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_ENTER_ROOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_ENTER_ROOM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_ENTER_ROOM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_ENTER_ROOM& from) {
    SC_ENTER_ROOM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_ENTER_ROOM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_ENTER_ROOM";
  }
  protected:
  explicit SC_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated .Protocol.hyps_user_info users = 2;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::Protocol::hyps_user_info* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info >*
      mutable_users();
  private:
  const ::Protocol::hyps_user_info& _internal_users(int index) const;
  ::Protocol::hyps_user_info* _internal_add_users();
  public:
  const ::Protocol::hyps_user_info& users(int index) const;
  ::Protocol::hyps_user_info* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info >&
      users() const;

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_ENTER_ROOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info > users_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class BC_ENTER_ROOM_OTHERS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.BC_ENTER_ROOM_OTHERS) */ {
 public:
  inline BC_ENTER_ROOM_OTHERS() : BC_ENTER_ROOM_OTHERS(nullptr) {}
  ~BC_ENTER_ROOM_OTHERS() override;
  explicit PROTOBUF_CONSTEXPR BC_ENTER_ROOM_OTHERS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BC_ENTER_ROOM_OTHERS(const BC_ENTER_ROOM_OTHERS& from);
  BC_ENTER_ROOM_OTHERS(BC_ENTER_ROOM_OTHERS&& from) noexcept
    : BC_ENTER_ROOM_OTHERS() {
    *this = ::std::move(from);
  }

  inline BC_ENTER_ROOM_OTHERS& operator=(const BC_ENTER_ROOM_OTHERS& from) {
    CopyFrom(from);
    return *this;
  }
  inline BC_ENTER_ROOM_OTHERS& operator=(BC_ENTER_ROOM_OTHERS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BC_ENTER_ROOM_OTHERS& default_instance() {
    return *internal_default_instance();
  }
  static inline const BC_ENTER_ROOM_OTHERS* internal_default_instance() {
    return reinterpret_cast<const BC_ENTER_ROOM_OTHERS*>(
               &_BC_ENTER_ROOM_OTHERS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BC_ENTER_ROOM_OTHERS& a, BC_ENTER_ROOM_OTHERS& b) {
    a.Swap(&b);
  }
  inline void Swap(BC_ENTER_ROOM_OTHERS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BC_ENTER_ROOM_OTHERS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BC_ENTER_ROOM_OTHERS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BC_ENTER_ROOM_OTHERS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BC_ENTER_ROOM_OTHERS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BC_ENTER_ROOM_OTHERS& from) {
    BC_ENTER_ROOM_OTHERS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BC_ENTER_ROOM_OTHERS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.BC_ENTER_ROOM_OTHERS";
  }
  protected:
  explicit BC_ENTER_ROOM_OTHERS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated .Protocol.hyps_user_info users = 2;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::Protocol::hyps_user_info* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info >*
      mutable_users();
  private:
  const ::Protocol::hyps_user_info& _internal_users(int index) const;
  ::Protocol::hyps_user_info* _internal_add_users();
  public:
  const ::Protocol::hyps_user_info& users(int index) const;
  ::Protocol::hyps_user_info* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info >&
      users() const;

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.BC_ENTER_ROOM_OTHERS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info > users_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_ENTER_GAME) */ {
 public:
  inline CS_ENTER_GAME() : CS_ENTER_GAME(nullptr) {}
  ~CS_ENTER_GAME() override;
  explicit PROTOBUF_CONSTEXPR CS_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_ENTER_GAME(const CS_ENTER_GAME& from);
  CS_ENTER_GAME(CS_ENTER_GAME&& from) noexcept
    : CS_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline CS_ENTER_GAME& operator=(const CS_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_ENTER_GAME& operator=(CS_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const CS_ENTER_GAME*>(
               &_CS_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CS_ENTER_GAME& a, CS_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_ENTER_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_ENTER_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_ENTER_GAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_ENTER_GAME& from) {
    CS_ENTER_GAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_ENTER_GAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_ENTER_GAME";
  }
  protected:
  explicit CS_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // uint64 player_id = 1;
  void clear_player_id();
  uint64_t player_id() const;
  void set_player_id(uint64_t value);
  private:
  uint64_t _internal_player_id() const;
  void _internal_set_player_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t player_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_ENTER_GAME) */ {
 public:
  inline SC_ENTER_GAME() : SC_ENTER_GAME(nullptr) {}
  ~SC_ENTER_GAME() override;
  explicit PROTOBUF_CONSTEXPR SC_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_ENTER_GAME(const SC_ENTER_GAME& from);
  SC_ENTER_GAME(SC_ENTER_GAME&& from) noexcept
    : SC_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline SC_ENTER_GAME& operator=(const SC_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_ENTER_GAME& operator=(SC_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const SC_ENTER_GAME*>(
               &_SC_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SC_ENTER_GAME& a, SC_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_ENTER_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_ENTER_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_ENTER_GAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_ENTER_GAME& from) {
    SC_ENTER_GAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_ENTER_GAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_ENTER_GAME";
  }
  protected:
  explicit SC_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMyPlayerFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .Protocol.hyps_pos_info my_player = 2;
  bool has_my_player() const;
  private:
  bool _internal_has_my_player() const;
  public:
  void clear_my_player();
  const ::Protocol::hyps_pos_info& my_player() const;
  PROTOBUF_NODISCARD ::Protocol::hyps_pos_info* release_my_player();
  ::Protocol::hyps_pos_info* mutable_my_player();
  void set_allocated_my_player(::Protocol::hyps_pos_info* my_player);
  private:
  const ::Protocol::hyps_pos_info& _internal_my_player() const;
  ::Protocol::hyps_pos_info* _internal_mutable_my_player();
  public:
  void unsafe_arena_set_allocated_my_player(
      ::Protocol::hyps_pos_info* my_player);
  ::Protocol::hyps_pos_info* unsafe_arena_release_my_player();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::hyps_pos_info* my_player_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_LEAVE_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.CS_LEAVE_GAME) */ {
 public:
  inline CS_LEAVE_GAME() : CS_LEAVE_GAME(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CS_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_LEAVE_GAME(const CS_LEAVE_GAME& from);
  CS_LEAVE_GAME(CS_LEAVE_GAME&& from) noexcept
    : CS_LEAVE_GAME() {
    *this = ::std::move(from);
  }

  inline CS_LEAVE_GAME& operator=(const CS_LEAVE_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_LEAVE_GAME& operator=(CS_LEAVE_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_LEAVE_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_LEAVE_GAME* internal_default_instance() {
    return reinterpret_cast<const CS_LEAVE_GAME*>(
               &_CS_LEAVE_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CS_LEAVE_GAME& a, CS_LEAVE_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_LEAVE_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_LEAVE_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_LEAVE_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_LEAVE_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CS_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CS_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_LEAVE_GAME";
  }
  protected:
  explicit CS_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.CS_LEAVE_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_LEAVE_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.SC_LEAVE_GAME) */ {
 public:
  inline SC_LEAVE_GAME() : SC_LEAVE_GAME(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SC_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_LEAVE_GAME(const SC_LEAVE_GAME& from);
  SC_LEAVE_GAME(SC_LEAVE_GAME&& from) noexcept
    : SC_LEAVE_GAME() {
    *this = ::std::move(from);
  }

  inline SC_LEAVE_GAME& operator=(const SC_LEAVE_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_LEAVE_GAME& operator=(SC_LEAVE_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_LEAVE_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_LEAVE_GAME* internal_default_instance() {
    return reinterpret_cast<const SC_LEAVE_GAME*>(
               &_SC_LEAVE_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SC_LEAVE_GAME& a, SC_LEAVE_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_LEAVE_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_LEAVE_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_LEAVE_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_LEAVE_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SC_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SC_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_LEAVE_GAME";
  }
  protected:
  explicit SC_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.SC_LEAVE_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class BC_LEAVE_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.BC_LEAVE_GAME) */ {
 public:
  inline BC_LEAVE_GAME() : BC_LEAVE_GAME(nullptr) {}
  explicit PROTOBUF_CONSTEXPR BC_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BC_LEAVE_GAME(const BC_LEAVE_GAME& from);
  BC_LEAVE_GAME(BC_LEAVE_GAME&& from) noexcept
    : BC_LEAVE_GAME() {
    *this = ::std::move(from);
  }

  inline BC_LEAVE_GAME& operator=(const BC_LEAVE_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline BC_LEAVE_GAME& operator=(BC_LEAVE_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BC_LEAVE_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const BC_LEAVE_GAME* internal_default_instance() {
    return reinterpret_cast<const BC_LEAVE_GAME*>(
               &_BC_LEAVE_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BC_LEAVE_GAME& a, BC_LEAVE_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(BC_LEAVE_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BC_LEAVE_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BC_LEAVE_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BC_LEAVE_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const BC_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const BC_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.BC_LEAVE_GAME";
  }
  protected:
  explicit BC_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.BC_LEAVE_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_SPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_SPAWN) */ {
 public:
  inline SC_SPAWN() : SC_SPAWN(nullptr) {}
  ~SC_SPAWN() override;
  explicit PROTOBUF_CONSTEXPR SC_SPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_SPAWN(const SC_SPAWN& from);
  SC_SPAWN(SC_SPAWN&& from) noexcept
    : SC_SPAWN() {
    *this = ::std::move(from);
  }

  inline SC_SPAWN& operator=(const SC_SPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_SPAWN& operator=(SC_SPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_SPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_SPAWN* internal_default_instance() {
    return reinterpret_cast<const SC_SPAWN*>(
               &_SC_SPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SC_SPAWN& a, SC_SPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_SPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_SPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_SPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_SPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_SPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_SPAWN& from) {
    SC_SPAWN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_SPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_SPAWN";
  }
  protected:
  explicit SC_SPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .Protocol.hyps_object_info players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Protocol::hyps_object_info* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_object_info >*
      mutable_players();
  private:
  const ::Protocol::hyps_object_info& _internal_players(int index) const;
  ::Protocol::hyps_object_info* _internal_add_players();
  public:
  const ::Protocol::hyps_object_info& players(int index) const;
  ::Protocol::hyps_object_info* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_object_info >&
      players() const;

  // @@protoc_insertion_point(class_scope:Protocol.SC_SPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_object_info > players_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class BC_SPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.BC_SPAWN) */ {
 public:
  inline BC_SPAWN() : BC_SPAWN(nullptr) {}
  ~BC_SPAWN() override;
  explicit PROTOBUF_CONSTEXPR BC_SPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BC_SPAWN(const BC_SPAWN& from);
  BC_SPAWN(BC_SPAWN&& from) noexcept
    : BC_SPAWN() {
    *this = ::std::move(from);
  }

  inline BC_SPAWN& operator=(const BC_SPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline BC_SPAWN& operator=(BC_SPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BC_SPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const BC_SPAWN* internal_default_instance() {
    return reinterpret_cast<const BC_SPAWN*>(
               &_BC_SPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BC_SPAWN& a, BC_SPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(BC_SPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BC_SPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BC_SPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BC_SPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BC_SPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BC_SPAWN& from) {
    BC_SPAWN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BC_SPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.BC_SPAWN";
  }
  protected:
  explicit BC_SPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .Protocol.hyps_object_info players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Protocol::hyps_object_info* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_object_info >*
      mutable_players();
  private:
  const ::Protocol::hyps_object_info& _internal_players(int index) const;
  ::Protocol::hyps_object_info* _internal_add_players();
  public:
  const ::Protocol::hyps_object_info& players(int index) const;
  ::Protocol::hyps_object_info* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_object_info >&
      players() const;

  // @@protoc_insertion_point(class_scope:Protocol.BC_SPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_object_info > players_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_DESPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_DESPAWN) */ {
 public:
  inline SC_DESPAWN() : SC_DESPAWN(nullptr) {}
  ~SC_DESPAWN() override;
  explicit PROTOBUF_CONSTEXPR SC_DESPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_DESPAWN(const SC_DESPAWN& from);
  SC_DESPAWN(SC_DESPAWN&& from) noexcept
    : SC_DESPAWN() {
    *this = ::std::move(from);
  }

  inline SC_DESPAWN& operator=(const SC_DESPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_DESPAWN& operator=(SC_DESPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_DESPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_DESPAWN* internal_default_instance() {
    return reinterpret_cast<const SC_DESPAWN*>(
               &_SC_DESPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SC_DESPAWN& a, SC_DESPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_DESPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_DESPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_DESPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_DESPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_DESPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_DESPAWN& from) {
    SC_DESPAWN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_DESPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_DESPAWN";
  }
  protected:
  explicit SC_DESPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdsFieldNumber = 1,
  };
  // repeated uint64 object_ids = 1;
  int object_ids_size() const;
  private:
  int _internal_object_ids_size() const;
  public:
  void clear_object_ids();
  private:
  uint64_t _internal_object_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_object_ids() const;
  void _internal_add_object_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_object_ids();
  public:
  uint64_t object_ids(int index) const;
  void set_object_ids(int index, uint64_t value);
  void add_object_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      object_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_object_ids();

  // @@protoc_insertion_point(class_scope:Protocol.SC_DESPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > object_ids_;
    mutable std::atomic<int> _object_ids_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class BC_DESPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.BC_DESPAWN) */ {
 public:
  inline BC_DESPAWN() : BC_DESPAWN(nullptr) {}
  ~BC_DESPAWN() override;
  explicit PROTOBUF_CONSTEXPR BC_DESPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BC_DESPAWN(const BC_DESPAWN& from);
  BC_DESPAWN(BC_DESPAWN&& from) noexcept
    : BC_DESPAWN() {
    *this = ::std::move(from);
  }

  inline BC_DESPAWN& operator=(const BC_DESPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline BC_DESPAWN& operator=(BC_DESPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BC_DESPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const BC_DESPAWN* internal_default_instance() {
    return reinterpret_cast<const BC_DESPAWN*>(
               &_BC_DESPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BC_DESPAWN& a, BC_DESPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(BC_DESPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BC_DESPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BC_DESPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BC_DESPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BC_DESPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BC_DESPAWN& from) {
    BC_DESPAWN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BC_DESPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.BC_DESPAWN";
  }
  protected:
  explicit BC_DESPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdsFieldNumber = 1,
  };
  // repeated uint64 object_ids = 1;
  int object_ids_size() const;
  private:
  int _internal_object_ids_size() const;
  public:
  void clear_object_ids();
  private:
  uint64_t _internal_object_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_object_ids() const;
  void _internal_add_object_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_object_ids();
  public:
  uint64_t object_ids(int index) const;
  void set_object_ids(int index, uint64_t value);
  void add_object_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      object_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_object_ids();

  // @@protoc_insertion_point(class_scope:Protocol.BC_DESPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > object_ids_;
    mutable std::atomic<int> _object_ids_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_MOVE_OBJECT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_MOVE_OBJECT) */ {
 public:
  inline CS_MOVE_OBJECT() : CS_MOVE_OBJECT(nullptr) {}
  ~CS_MOVE_OBJECT() override;
  explicit PROTOBUF_CONSTEXPR CS_MOVE_OBJECT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_MOVE_OBJECT(const CS_MOVE_OBJECT& from);
  CS_MOVE_OBJECT(CS_MOVE_OBJECT&& from) noexcept
    : CS_MOVE_OBJECT() {
    *this = ::std::move(from);
  }

  inline CS_MOVE_OBJECT& operator=(const CS_MOVE_OBJECT& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_MOVE_OBJECT& operator=(CS_MOVE_OBJECT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_MOVE_OBJECT& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_MOVE_OBJECT* internal_default_instance() {
    return reinterpret_cast<const CS_MOVE_OBJECT*>(
               &_CS_MOVE_OBJECT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CS_MOVE_OBJECT& a, CS_MOVE_OBJECT& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_MOVE_OBJECT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_MOVE_OBJECT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_MOVE_OBJECT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_MOVE_OBJECT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_MOVE_OBJECT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_MOVE_OBJECT& from) {
    CS_MOVE_OBJECT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_MOVE_OBJECT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_MOVE_OBJECT";
  }
  protected:
  explicit CS_MOVE_OBJECT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMoveInfoFieldNumber = 1,
    kMoveStateFieldNumber = 2,
  };
  // .Protocol.hyps_pos_info move_info = 1;
  bool has_move_info() const;
  private:
  bool _internal_has_move_info() const;
  public:
  void clear_move_info();
  const ::Protocol::hyps_pos_info& move_info() const;
  PROTOBUF_NODISCARD ::Protocol::hyps_pos_info* release_move_info();
  ::Protocol::hyps_pos_info* mutable_move_info();
  void set_allocated_move_info(::Protocol::hyps_pos_info* move_info);
  private:
  const ::Protocol::hyps_pos_info& _internal_move_info() const;
  ::Protocol::hyps_pos_info* _internal_mutable_move_info();
  public:
  void unsafe_arena_set_allocated_move_info(
      ::Protocol::hyps_pos_info* move_info);
  ::Protocol::hyps_pos_info* unsafe_arena_release_move_info();

  // .Protocol.hype_move_state move_state = 2;
  void clear_move_state();
  ::Protocol::hype_move_state move_state() const;
  void set_move_state(::Protocol::hype_move_state value);
  private:
  ::Protocol::hype_move_state _internal_move_state() const;
  void _internal_set_move_state(::Protocol::hype_move_state value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_MOVE_OBJECT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::hyps_pos_info* move_info_;
    int move_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_MOVE_OBJECT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_MOVE_OBJECT) */ {
 public:
  inline SC_MOVE_OBJECT() : SC_MOVE_OBJECT(nullptr) {}
  ~SC_MOVE_OBJECT() override;
  explicit PROTOBUF_CONSTEXPR SC_MOVE_OBJECT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_MOVE_OBJECT(const SC_MOVE_OBJECT& from);
  SC_MOVE_OBJECT(SC_MOVE_OBJECT&& from) noexcept
    : SC_MOVE_OBJECT() {
    *this = ::std::move(from);
  }

  inline SC_MOVE_OBJECT& operator=(const SC_MOVE_OBJECT& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_MOVE_OBJECT& operator=(SC_MOVE_OBJECT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_MOVE_OBJECT& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_MOVE_OBJECT* internal_default_instance() {
    return reinterpret_cast<const SC_MOVE_OBJECT*>(
               &_SC_MOVE_OBJECT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SC_MOVE_OBJECT& a, SC_MOVE_OBJECT& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_MOVE_OBJECT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_MOVE_OBJECT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_MOVE_OBJECT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_MOVE_OBJECT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_MOVE_OBJECT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_MOVE_OBJECT& from) {
    SC_MOVE_OBJECT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_MOVE_OBJECT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_MOVE_OBJECT";
  }
  protected:
  explicit SC_MOVE_OBJECT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMoveInfoFieldNumber = 1,
    kMoveStateFieldNumber = 2,
  };
  // .Protocol.hyps_pos_info move_info = 1;
  bool has_move_info() const;
  private:
  bool _internal_has_move_info() const;
  public:
  void clear_move_info();
  const ::Protocol::hyps_pos_info& move_info() const;
  PROTOBUF_NODISCARD ::Protocol::hyps_pos_info* release_move_info();
  ::Protocol::hyps_pos_info* mutable_move_info();
  void set_allocated_move_info(::Protocol::hyps_pos_info* move_info);
  private:
  const ::Protocol::hyps_pos_info& _internal_move_info() const;
  ::Protocol::hyps_pos_info* _internal_mutable_move_info();
  public:
  void unsafe_arena_set_allocated_move_info(
      ::Protocol::hyps_pos_info* move_info);
  ::Protocol::hyps_pos_info* unsafe_arena_release_move_info();

  // .Protocol.hype_move_state move_state = 2;
  void clear_move_state();
  ::Protocol::hype_move_state move_state() const;
  void set_move_state(::Protocol::hype_move_state value);
  private:
  ::Protocol::hype_move_state _internal_move_state() const;
  void _internal_set_move_state(::Protocol::hype_move_state value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_MOVE_OBJECT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::hyps_pos_info* move_info_;
    int move_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_CHAT) */ {
 public:
  inline CS_CHAT() : CS_CHAT(nullptr) {}
  ~CS_CHAT() override;
  explicit PROTOBUF_CONSTEXPR CS_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_CHAT(const CS_CHAT& from);
  CS_CHAT(CS_CHAT&& from) noexcept
    : CS_CHAT() {
    *this = ::std::move(from);
  }

  inline CS_CHAT& operator=(const CS_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_CHAT& operator=(CS_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_CHAT* internal_default_instance() {
    return reinterpret_cast<const CS_CHAT*>(
               &_CS_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CS_CHAT& a, CS_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_CHAT& from) {
    CS_CHAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_CHAT";
  }
  protected:
  explicit CS_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_CHAT) */ {
 public:
  inline SC_CHAT() : SC_CHAT(nullptr) {}
  ~SC_CHAT() override;
  explicit PROTOBUF_CONSTEXPR SC_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_CHAT(const SC_CHAT& from);
  SC_CHAT(SC_CHAT&& from) noexcept
    : SC_CHAT() {
    *this = ::std::move(from);
  }

  inline SC_CHAT& operator=(const SC_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_CHAT& operator=(SC_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_CHAT* internal_default_instance() {
    return reinterpret_cast<const SC_CHAT*>(
               &_SC_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SC_CHAT& a, SC_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_CHAT& from) {
    SC_CHAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_CHAT";
  }
  protected:
  explicit SC_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 3,
    kUserIdFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 3;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // uint64 userId = 2;
  void clear_userid();
  uint64_t userid() const;
  void set_userid(uint64_t value);
  private:
  uint64_t _internal_userid() const;
  void _internal_set_userid(uint64_t value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    uint64_t userid_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class BC_GL_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.BC_GL_CHAT) */ {
 public:
  inline BC_GL_CHAT() : BC_GL_CHAT(nullptr) {}
  ~BC_GL_CHAT() override;
  explicit PROTOBUF_CONSTEXPR BC_GL_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BC_GL_CHAT(const BC_GL_CHAT& from);
  BC_GL_CHAT(BC_GL_CHAT&& from) noexcept
    : BC_GL_CHAT() {
    *this = ::std::move(from);
  }

  inline BC_GL_CHAT& operator=(const BC_GL_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline BC_GL_CHAT& operator=(BC_GL_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BC_GL_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const BC_GL_CHAT* internal_default_instance() {
    return reinterpret_cast<const BC_GL_CHAT*>(
               &_BC_GL_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(BC_GL_CHAT& a, BC_GL_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(BC_GL_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BC_GL_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BC_GL_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BC_GL_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BC_GL_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BC_GL_CHAT& from) {
    BC_GL_CHAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BC_GL_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.BC_GL_CHAT";
  }
  protected:
  explicit BC_GL_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.BC_GL_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_ECHO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_ECHO) */ {
 public:
  inline CS_ECHO() : CS_ECHO(nullptr) {}
  ~CS_ECHO() override;
  explicit PROTOBUF_CONSTEXPR CS_ECHO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_ECHO(const CS_ECHO& from);
  CS_ECHO(CS_ECHO&& from) noexcept
    : CS_ECHO() {
    *this = ::std::move(from);
  }

  inline CS_ECHO& operator=(const CS_ECHO& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_ECHO& operator=(CS_ECHO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_ECHO& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_ECHO* internal_default_instance() {
    return reinterpret_cast<const CS_ECHO*>(
               &_CS_ECHO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CS_ECHO& a, CS_ECHO& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_ECHO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_ECHO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_ECHO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_ECHO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_ECHO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_ECHO& from) {
    CS_ECHO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_ECHO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_ECHO";
  }
  protected:
  explicit CS_ECHO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_ECHO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class BC_GL_ECHO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.BC_GL_ECHO) */ {
 public:
  inline BC_GL_ECHO() : BC_GL_ECHO(nullptr) {}
  ~BC_GL_ECHO() override;
  explicit PROTOBUF_CONSTEXPR BC_GL_ECHO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BC_GL_ECHO(const BC_GL_ECHO& from);
  BC_GL_ECHO(BC_GL_ECHO&& from) noexcept
    : BC_GL_ECHO() {
    *this = ::std::move(from);
  }

  inline BC_GL_ECHO& operator=(const BC_GL_ECHO& from) {
    CopyFrom(from);
    return *this;
  }
  inline BC_GL_ECHO& operator=(BC_GL_ECHO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BC_GL_ECHO& default_instance() {
    return *internal_default_instance();
  }
  static inline const BC_GL_ECHO* internal_default_instance() {
    return reinterpret_cast<const BC_GL_ECHO*>(
               &_BC_GL_ECHO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(BC_GL_ECHO& a, BC_GL_ECHO& b) {
    a.Swap(&b);
  }
  inline void Swap(BC_GL_ECHO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BC_GL_ECHO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BC_GL_ECHO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BC_GL_ECHO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BC_GL_ECHO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BC_GL_ECHO& from) {
    BC_GL_ECHO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BC_GL_ECHO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.BC_GL_ECHO";
  }
  protected:
  explicit BC_GL_ECHO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.BC_GL_ECHO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CS_LOGIN

// bool bIsDevLogin = 1;
inline void CS_LOGIN::clear_bisdevlogin() {
  _impl_.bisdevlogin_ = false;
}
inline bool CS_LOGIN::_internal_bisdevlogin() const {
  return _impl_.bisdevlogin_;
}
inline bool CS_LOGIN::bisdevlogin() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_LOGIN.bIsDevLogin)
  return _internal_bisdevlogin();
}
inline void CS_LOGIN::_internal_set_bisdevlogin(bool value) {
  
  _impl_.bisdevlogin_ = value;
}
inline void CS_LOGIN::set_bisdevlogin(bool value) {
  _internal_set_bisdevlogin(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_LOGIN.bIsDevLogin)
}

// string user_name = 2;
inline void CS_LOGIN::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& CS_LOGIN::user_name() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_LOGIN.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_LOGIN::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CS_LOGIN.user_name)
}
inline std::string* CS_LOGIN::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_LOGIN.user_name)
  return _s;
}
inline const std::string& CS_LOGIN::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void CS_LOGIN::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_LOGIN::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_LOGIN::release_user_name() {
  // @@protoc_insertion_point(field_release:Protocol.CS_LOGIN.user_name)
  return _impl_.user_name_.Release();
}
inline void CS_LOGIN::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_LOGIN.user_name)
}

// string passwd = 3;
inline void CS_LOGIN::clear_passwd() {
  _impl_.passwd_.ClearToEmpty();
}
inline const std::string& CS_LOGIN::passwd() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_LOGIN.passwd)
  return _internal_passwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_LOGIN::set_passwd(ArgT0&& arg0, ArgT... args) {
 
 _impl_.passwd_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CS_LOGIN.passwd)
}
inline std::string* CS_LOGIN::mutable_passwd() {
  std::string* _s = _internal_mutable_passwd();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_LOGIN.passwd)
  return _s;
}
inline const std::string& CS_LOGIN::_internal_passwd() const {
  return _impl_.passwd_.Get();
}
inline void CS_LOGIN::_internal_set_passwd(const std::string& value) {
  
  _impl_.passwd_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_LOGIN::_internal_mutable_passwd() {
  
  return _impl_.passwd_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_LOGIN::release_passwd() {
  // @@protoc_insertion_point(field_release:Protocol.CS_LOGIN.passwd)
  return _impl_.passwd_.Release();
}
inline void CS_LOGIN::set_allocated_passwd(std::string* passwd) {
  if (passwd != nullptr) {
    
  } else {
    
  }
  _impl_.passwd_.SetAllocated(passwd, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.passwd_.IsDefault()) {
    _impl_.passwd_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_LOGIN.passwd)
}

// -------------------------------------------------------------------

// SC_LOGIN

// bool success = 1;
inline void SC_LOGIN::clear_success() {
  _impl_.success_ = false;
}
inline bool SC_LOGIN::_internal_success() const {
  return _impl_.success_;
}
inline bool SC_LOGIN::success() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_LOGIN.success)
  return _internal_success();
}
inline void SC_LOGIN::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void SC_LOGIN::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_LOGIN.success)
}

// .Protocol.hyps_user_info user_info = 2;
inline bool SC_LOGIN::_internal_has_user_info() const {
  return this != internal_default_instance() && _impl_.user_info_ != nullptr;
}
inline bool SC_LOGIN::has_user_info() const {
  return _internal_has_user_info();
}
inline const ::Protocol::hyps_user_info& SC_LOGIN::_internal_user_info() const {
  const ::Protocol::hyps_user_info* p = _impl_.user_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::hyps_user_info&>(
      ::Protocol::_hyps_user_info_default_instance_);
}
inline const ::Protocol::hyps_user_info& SC_LOGIN::user_info() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_LOGIN.user_info)
  return _internal_user_info();
}
inline void SC_LOGIN::unsafe_arena_set_allocated_user_info(
    ::Protocol::hyps_user_info* user_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_info_);
  }
  _impl_.user_info_ = user_info;
  if (user_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.SC_LOGIN.user_info)
}
inline ::Protocol::hyps_user_info* SC_LOGIN::release_user_info() {
  
  ::Protocol::hyps_user_info* temp = _impl_.user_info_;
  _impl_.user_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::hyps_user_info* SC_LOGIN::unsafe_arena_release_user_info() {
  // @@protoc_insertion_point(field_release:Protocol.SC_LOGIN.user_info)
  
  ::Protocol::hyps_user_info* temp = _impl_.user_info_;
  _impl_.user_info_ = nullptr;
  return temp;
}
inline ::Protocol::hyps_user_info* SC_LOGIN::_internal_mutable_user_info() {
  
  if (_impl_.user_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::hyps_user_info>(GetArenaForAllocation());
    _impl_.user_info_ = p;
  }
  return _impl_.user_info_;
}
inline ::Protocol::hyps_user_info* SC_LOGIN::mutable_user_info() {
  ::Protocol::hyps_user_info* _msg = _internal_mutable_user_info();
  // @@protoc_insertion_point(field_mutable:Protocol.SC_LOGIN.user_info)
  return _msg;
}
inline void SC_LOGIN::set_allocated_user_info(::Protocol::hyps_user_info* user_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_info_);
  }
  if (user_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_info));
    if (message_arena != submessage_arena) {
      user_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_info_ = user_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.SC_LOGIN.user_info)
}

// repeated .Protocol.hyps_pos_info players = 3;
inline int SC_LOGIN::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int SC_LOGIN::players_size() const {
  return _internal_players_size();
}
inline ::Protocol::hyps_pos_info* SC_LOGIN::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.SC_LOGIN.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_pos_info >*
SC_LOGIN::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.SC_LOGIN.players)
  return &_impl_.players_;
}
inline const ::Protocol::hyps_pos_info& SC_LOGIN::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::Protocol::hyps_pos_info& SC_LOGIN::players(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.SC_LOGIN.players)
  return _internal_players(index);
}
inline ::Protocol::hyps_pos_info* SC_LOGIN::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::Protocol::hyps_pos_info* SC_LOGIN::add_players() {
  ::Protocol::hyps_pos_info* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:Protocol.SC_LOGIN.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_pos_info >&
SC_LOGIN::players() const {
  // @@protoc_insertion_point(field_list:Protocol.SC_LOGIN.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// CS_REGIST

// string user_name = 1;
inline void CS_REGIST::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& CS_REGIST::user_name() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_REGIST.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_REGIST::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CS_REGIST.user_name)
}
inline std::string* CS_REGIST::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_REGIST.user_name)
  return _s;
}
inline const std::string& CS_REGIST::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void CS_REGIST::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_REGIST::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_REGIST::release_user_name() {
  // @@protoc_insertion_point(field_release:Protocol.CS_REGIST.user_name)
  return _impl_.user_name_.Release();
}
inline void CS_REGIST::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_REGIST.user_name)
}

// string passwd = 2;
inline void CS_REGIST::clear_passwd() {
  _impl_.passwd_.ClearToEmpty();
}
inline const std::string& CS_REGIST::passwd() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_REGIST.passwd)
  return _internal_passwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_REGIST::set_passwd(ArgT0&& arg0, ArgT... args) {
 
 _impl_.passwd_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CS_REGIST.passwd)
}
inline std::string* CS_REGIST::mutable_passwd() {
  std::string* _s = _internal_mutable_passwd();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_REGIST.passwd)
  return _s;
}
inline const std::string& CS_REGIST::_internal_passwd() const {
  return _impl_.passwd_.Get();
}
inline void CS_REGIST::_internal_set_passwd(const std::string& value) {
  
  _impl_.passwd_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_REGIST::_internal_mutable_passwd() {
  
  return _impl_.passwd_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_REGIST::release_passwd() {
  // @@protoc_insertion_point(field_release:Protocol.CS_REGIST.passwd)
  return _impl_.passwd_.Release();
}
inline void CS_REGIST::set_allocated_passwd(std::string* passwd) {
  if (passwd != nullptr) {
    
  } else {
    
  }
  _impl_.passwd_.SetAllocated(passwd, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.passwd_.IsDefault()) {
    _impl_.passwd_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_REGIST.passwd)
}

// -------------------------------------------------------------------

// SC_REGIST

// bool success = 1;
inline void SC_REGIST::clear_success() {
  _impl_.success_ = false;
}
inline bool SC_REGIST::_internal_success() const {
  return _impl_.success_;
}
inline bool SC_REGIST::success() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_REGIST.success)
  return _internal_success();
}
inline void SC_REGIST::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void SC_REGIST::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_REGIST.success)
}

// string user_name = 2;
inline void SC_REGIST::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& SC_REGIST::user_name() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_REGIST.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SC_REGIST::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.SC_REGIST.user_name)
}
inline std::string* SC_REGIST::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:Protocol.SC_REGIST.user_name)
  return _s;
}
inline const std::string& SC_REGIST::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void SC_REGIST::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SC_REGIST::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SC_REGIST::release_user_name() {
  // @@protoc_insertion_point(field_release:Protocol.SC_REGIST.user_name)
  return _impl_.user_name_.Release();
}
inline void SC_REGIST::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.SC_REGIST.user_name)
}

// -------------------------------------------------------------------

// CS_ENTER_ROOM

// string room_name = 1;
inline void CS_ENTER_ROOM::clear_room_name() {
  _impl_.room_name_.ClearToEmpty();
}
inline const std::string& CS_ENTER_ROOM::room_name() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_ENTER_ROOM.room_name)
  return _internal_room_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_ENTER_ROOM::set_room_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CS_ENTER_ROOM.room_name)
}
inline std::string* CS_ENTER_ROOM::mutable_room_name() {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_ENTER_ROOM.room_name)
  return _s;
}
inline const std::string& CS_ENTER_ROOM::_internal_room_name() const {
  return _impl_.room_name_.Get();
}
inline void CS_ENTER_ROOM::_internal_set_room_name(const std::string& value) {
  
  _impl_.room_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_ENTER_ROOM::_internal_mutable_room_name() {
  
  return _impl_.room_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_ENTER_ROOM::release_room_name() {
  // @@protoc_insertion_point(field_release:Protocol.CS_ENTER_ROOM.room_name)
  return _impl_.room_name_.Release();
}
inline void CS_ENTER_ROOM::set_allocated_room_name(std::string* room_name) {
  if (room_name != nullptr) {
    
  } else {
    
  }
  _impl_.room_name_.SetAllocated(room_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_ENTER_ROOM.room_name)
}

// uint64 userId = 2;
inline void CS_ENTER_ROOM::clear_userid() {
  _impl_.userid_ = uint64_t{0u};
}
inline uint64_t CS_ENTER_ROOM::_internal_userid() const {
  return _impl_.userid_;
}
inline uint64_t CS_ENTER_ROOM::userid() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_ENTER_ROOM.userId)
  return _internal_userid();
}
inline void CS_ENTER_ROOM::_internal_set_userid(uint64_t value) {
  
  _impl_.userid_ = value;
}
inline void CS_ENTER_ROOM::set_userid(uint64_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_ENTER_ROOM.userId)
}

// -------------------------------------------------------------------

// SC_ENTER_ROOM

// bool success = 1;
inline void SC_ENTER_ROOM::clear_success() {
  _impl_.success_ = false;
}
inline bool SC_ENTER_ROOM::_internal_success() const {
  return _impl_.success_;
}
inline bool SC_ENTER_ROOM::success() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_ENTER_ROOM.success)
  return _internal_success();
}
inline void SC_ENTER_ROOM::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void SC_ENTER_ROOM::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_ENTER_ROOM.success)
}

// repeated .Protocol.hyps_user_info users = 2;
inline int SC_ENTER_ROOM::_internal_users_size() const {
  return _impl_.users_.size();
}
inline int SC_ENTER_ROOM::users_size() const {
  return _internal_users_size();
}
inline ::Protocol::hyps_user_info* SC_ENTER_ROOM::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.SC_ENTER_ROOM.users)
  return _impl_.users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info >*
SC_ENTER_ROOM::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.SC_ENTER_ROOM.users)
  return &_impl_.users_;
}
inline const ::Protocol::hyps_user_info& SC_ENTER_ROOM::_internal_users(int index) const {
  return _impl_.users_.Get(index);
}
inline const ::Protocol::hyps_user_info& SC_ENTER_ROOM::users(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.SC_ENTER_ROOM.users)
  return _internal_users(index);
}
inline ::Protocol::hyps_user_info* SC_ENTER_ROOM::_internal_add_users() {
  return _impl_.users_.Add();
}
inline ::Protocol::hyps_user_info* SC_ENTER_ROOM::add_users() {
  ::Protocol::hyps_user_info* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:Protocol.SC_ENTER_ROOM.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info >&
SC_ENTER_ROOM::users() const {
  // @@protoc_insertion_point(field_list:Protocol.SC_ENTER_ROOM.users)
  return _impl_.users_;
}

// -------------------------------------------------------------------

// BC_ENTER_ROOM_OTHERS

// bool success = 1;
inline void BC_ENTER_ROOM_OTHERS::clear_success() {
  _impl_.success_ = false;
}
inline bool BC_ENTER_ROOM_OTHERS::_internal_success() const {
  return _impl_.success_;
}
inline bool BC_ENTER_ROOM_OTHERS::success() const {
  // @@protoc_insertion_point(field_get:Protocol.BC_ENTER_ROOM_OTHERS.success)
  return _internal_success();
}
inline void BC_ENTER_ROOM_OTHERS::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void BC_ENTER_ROOM_OTHERS::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.BC_ENTER_ROOM_OTHERS.success)
}

// repeated .Protocol.hyps_user_info users = 2;
inline int BC_ENTER_ROOM_OTHERS::_internal_users_size() const {
  return _impl_.users_.size();
}
inline int BC_ENTER_ROOM_OTHERS::users_size() const {
  return _internal_users_size();
}
inline ::Protocol::hyps_user_info* BC_ENTER_ROOM_OTHERS::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.BC_ENTER_ROOM_OTHERS.users)
  return _impl_.users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info >*
BC_ENTER_ROOM_OTHERS::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.BC_ENTER_ROOM_OTHERS.users)
  return &_impl_.users_;
}
inline const ::Protocol::hyps_user_info& BC_ENTER_ROOM_OTHERS::_internal_users(int index) const {
  return _impl_.users_.Get(index);
}
inline const ::Protocol::hyps_user_info& BC_ENTER_ROOM_OTHERS::users(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.BC_ENTER_ROOM_OTHERS.users)
  return _internal_users(index);
}
inline ::Protocol::hyps_user_info* BC_ENTER_ROOM_OTHERS::_internal_add_users() {
  return _impl_.users_.Add();
}
inline ::Protocol::hyps_user_info* BC_ENTER_ROOM_OTHERS::add_users() {
  ::Protocol::hyps_user_info* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:Protocol.BC_ENTER_ROOM_OTHERS.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_user_info >&
BC_ENTER_ROOM_OTHERS::users() const {
  // @@protoc_insertion_point(field_list:Protocol.BC_ENTER_ROOM_OTHERS.users)
  return _impl_.users_;
}

// -------------------------------------------------------------------

// CS_ENTER_GAME

// uint64 player_id = 1;
inline void CS_ENTER_GAME::clear_player_id() {
  _impl_.player_id_ = uint64_t{0u};
}
inline uint64_t CS_ENTER_GAME::_internal_player_id() const {
  return _impl_.player_id_;
}
inline uint64_t CS_ENTER_GAME::player_id() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_ENTER_GAME.player_id)
  return _internal_player_id();
}
inline void CS_ENTER_GAME::_internal_set_player_id(uint64_t value) {
  
  _impl_.player_id_ = value;
}
inline void CS_ENTER_GAME::set_player_id(uint64_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_ENTER_GAME.player_id)
}

// -------------------------------------------------------------------

// SC_ENTER_GAME

// bool success = 1;
inline void SC_ENTER_GAME::clear_success() {
  _impl_.success_ = false;
}
inline bool SC_ENTER_GAME::_internal_success() const {
  return _impl_.success_;
}
inline bool SC_ENTER_GAME::success() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_ENTER_GAME.success)
  return _internal_success();
}
inline void SC_ENTER_GAME::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void SC_ENTER_GAME::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_ENTER_GAME.success)
}

// .Protocol.hyps_pos_info my_player = 2;
inline bool SC_ENTER_GAME::_internal_has_my_player() const {
  return this != internal_default_instance() && _impl_.my_player_ != nullptr;
}
inline bool SC_ENTER_GAME::has_my_player() const {
  return _internal_has_my_player();
}
inline const ::Protocol::hyps_pos_info& SC_ENTER_GAME::_internal_my_player() const {
  const ::Protocol::hyps_pos_info* p = _impl_.my_player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::hyps_pos_info&>(
      ::Protocol::_hyps_pos_info_default_instance_);
}
inline const ::Protocol::hyps_pos_info& SC_ENTER_GAME::my_player() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_ENTER_GAME.my_player)
  return _internal_my_player();
}
inline void SC_ENTER_GAME::unsafe_arena_set_allocated_my_player(
    ::Protocol::hyps_pos_info* my_player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.my_player_);
  }
  _impl_.my_player_ = my_player;
  if (my_player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.SC_ENTER_GAME.my_player)
}
inline ::Protocol::hyps_pos_info* SC_ENTER_GAME::release_my_player() {
  
  ::Protocol::hyps_pos_info* temp = _impl_.my_player_;
  _impl_.my_player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::hyps_pos_info* SC_ENTER_GAME::unsafe_arena_release_my_player() {
  // @@protoc_insertion_point(field_release:Protocol.SC_ENTER_GAME.my_player)
  
  ::Protocol::hyps_pos_info* temp = _impl_.my_player_;
  _impl_.my_player_ = nullptr;
  return temp;
}
inline ::Protocol::hyps_pos_info* SC_ENTER_GAME::_internal_mutable_my_player() {
  
  if (_impl_.my_player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::hyps_pos_info>(GetArenaForAllocation());
    _impl_.my_player_ = p;
  }
  return _impl_.my_player_;
}
inline ::Protocol::hyps_pos_info* SC_ENTER_GAME::mutable_my_player() {
  ::Protocol::hyps_pos_info* _msg = _internal_mutable_my_player();
  // @@protoc_insertion_point(field_mutable:Protocol.SC_ENTER_GAME.my_player)
  return _msg;
}
inline void SC_ENTER_GAME::set_allocated_my_player(::Protocol::hyps_pos_info* my_player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.my_player_);
  }
  if (my_player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(my_player));
    if (message_arena != submessage_arena) {
      my_player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, my_player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.my_player_ = my_player;
  // @@protoc_insertion_point(field_set_allocated:Protocol.SC_ENTER_GAME.my_player)
}

// -------------------------------------------------------------------

// CS_LEAVE_GAME

// -------------------------------------------------------------------

// SC_LEAVE_GAME

// -------------------------------------------------------------------

// BC_LEAVE_GAME

// -------------------------------------------------------------------

// SC_SPAWN

// repeated .Protocol.hyps_object_info players = 1;
inline int SC_SPAWN::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int SC_SPAWN::players_size() const {
  return _internal_players_size();
}
inline ::Protocol::hyps_object_info* SC_SPAWN::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.SC_SPAWN.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_object_info >*
SC_SPAWN::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.SC_SPAWN.players)
  return &_impl_.players_;
}
inline const ::Protocol::hyps_object_info& SC_SPAWN::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::Protocol::hyps_object_info& SC_SPAWN::players(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.SC_SPAWN.players)
  return _internal_players(index);
}
inline ::Protocol::hyps_object_info* SC_SPAWN::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::Protocol::hyps_object_info* SC_SPAWN::add_players() {
  ::Protocol::hyps_object_info* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:Protocol.SC_SPAWN.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_object_info >&
SC_SPAWN::players() const {
  // @@protoc_insertion_point(field_list:Protocol.SC_SPAWN.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// BC_SPAWN

// repeated .Protocol.hyps_object_info players = 1;
inline int BC_SPAWN::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int BC_SPAWN::players_size() const {
  return _internal_players_size();
}
inline ::Protocol::hyps_object_info* BC_SPAWN::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.BC_SPAWN.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_object_info >*
BC_SPAWN::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.BC_SPAWN.players)
  return &_impl_.players_;
}
inline const ::Protocol::hyps_object_info& BC_SPAWN::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::Protocol::hyps_object_info& BC_SPAWN::players(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.BC_SPAWN.players)
  return _internal_players(index);
}
inline ::Protocol::hyps_object_info* BC_SPAWN::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::Protocol::hyps_object_info* BC_SPAWN::add_players() {
  ::Protocol::hyps_object_info* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:Protocol.BC_SPAWN.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::hyps_object_info >&
BC_SPAWN::players() const {
  // @@protoc_insertion_point(field_list:Protocol.BC_SPAWN.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// SC_DESPAWN

// repeated uint64 object_ids = 1;
inline int SC_DESPAWN::_internal_object_ids_size() const {
  return _impl_.object_ids_.size();
}
inline int SC_DESPAWN::object_ids_size() const {
  return _internal_object_ids_size();
}
inline void SC_DESPAWN::clear_object_ids() {
  _impl_.object_ids_.Clear();
}
inline uint64_t SC_DESPAWN::_internal_object_ids(int index) const {
  return _impl_.object_ids_.Get(index);
}
inline uint64_t SC_DESPAWN::object_ids(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.SC_DESPAWN.object_ids)
  return _internal_object_ids(index);
}
inline void SC_DESPAWN::set_object_ids(int index, uint64_t value) {
  _impl_.object_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.SC_DESPAWN.object_ids)
}
inline void SC_DESPAWN::_internal_add_object_ids(uint64_t value) {
  _impl_.object_ids_.Add(value);
}
inline void SC_DESPAWN::add_object_ids(uint64_t value) {
  _internal_add_object_ids(value);
  // @@protoc_insertion_point(field_add:Protocol.SC_DESPAWN.object_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SC_DESPAWN::_internal_object_ids() const {
  return _impl_.object_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SC_DESPAWN::object_ids() const {
  // @@protoc_insertion_point(field_list:Protocol.SC_DESPAWN.object_ids)
  return _internal_object_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SC_DESPAWN::_internal_mutable_object_ids() {
  return &_impl_.object_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SC_DESPAWN::mutable_object_ids() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.SC_DESPAWN.object_ids)
  return _internal_mutable_object_ids();
}

// -------------------------------------------------------------------

// BC_DESPAWN

// repeated uint64 object_ids = 1;
inline int BC_DESPAWN::_internal_object_ids_size() const {
  return _impl_.object_ids_.size();
}
inline int BC_DESPAWN::object_ids_size() const {
  return _internal_object_ids_size();
}
inline void BC_DESPAWN::clear_object_ids() {
  _impl_.object_ids_.Clear();
}
inline uint64_t BC_DESPAWN::_internal_object_ids(int index) const {
  return _impl_.object_ids_.Get(index);
}
inline uint64_t BC_DESPAWN::object_ids(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.BC_DESPAWN.object_ids)
  return _internal_object_ids(index);
}
inline void BC_DESPAWN::set_object_ids(int index, uint64_t value) {
  _impl_.object_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.BC_DESPAWN.object_ids)
}
inline void BC_DESPAWN::_internal_add_object_ids(uint64_t value) {
  _impl_.object_ids_.Add(value);
}
inline void BC_DESPAWN::add_object_ids(uint64_t value) {
  _internal_add_object_ids(value);
  // @@protoc_insertion_point(field_add:Protocol.BC_DESPAWN.object_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
BC_DESPAWN::_internal_object_ids() const {
  return _impl_.object_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
BC_DESPAWN::object_ids() const {
  // @@protoc_insertion_point(field_list:Protocol.BC_DESPAWN.object_ids)
  return _internal_object_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
BC_DESPAWN::_internal_mutable_object_ids() {
  return &_impl_.object_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
BC_DESPAWN::mutable_object_ids() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.BC_DESPAWN.object_ids)
  return _internal_mutable_object_ids();
}

// -------------------------------------------------------------------

// CS_MOVE_OBJECT

// .Protocol.hyps_pos_info move_info = 1;
inline bool CS_MOVE_OBJECT::_internal_has_move_info() const {
  return this != internal_default_instance() && _impl_.move_info_ != nullptr;
}
inline bool CS_MOVE_OBJECT::has_move_info() const {
  return _internal_has_move_info();
}
inline const ::Protocol::hyps_pos_info& CS_MOVE_OBJECT::_internal_move_info() const {
  const ::Protocol::hyps_pos_info* p = _impl_.move_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::hyps_pos_info&>(
      ::Protocol::_hyps_pos_info_default_instance_);
}
inline const ::Protocol::hyps_pos_info& CS_MOVE_OBJECT::move_info() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_MOVE_OBJECT.move_info)
  return _internal_move_info();
}
inline void CS_MOVE_OBJECT::unsafe_arena_set_allocated_move_info(
    ::Protocol::hyps_pos_info* move_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.move_info_);
  }
  _impl_.move_info_ = move_info;
  if (move_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.CS_MOVE_OBJECT.move_info)
}
inline ::Protocol::hyps_pos_info* CS_MOVE_OBJECT::release_move_info() {
  
  ::Protocol::hyps_pos_info* temp = _impl_.move_info_;
  _impl_.move_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::hyps_pos_info* CS_MOVE_OBJECT::unsafe_arena_release_move_info() {
  // @@protoc_insertion_point(field_release:Protocol.CS_MOVE_OBJECT.move_info)
  
  ::Protocol::hyps_pos_info* temp = _impl_.move_info_;
  _impl_.move_info_ = nullptr;
  return temp;
}
inline ::Protocol::hyps_pos_info* CS_MOVE_OBJECT::_internal_mutable_move_info() {
  
  if (_impl_.move_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::hyps_pos_info>(GetArenaForAllocation());
    _impl_.move_info_ = p;
  }
  return _impl_.move_info_;
}
inline ::Protocol::hyps_pos_info* CS_MOVE_OBJECT::mutable_move_info() {
  ::Protocol::hyps_pos_info* _msg = _internal_mutable_move_info();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_MOVE_OBJECT.move_info)
  return _msg;
}
inline void CS_MOVE_OBJECT::set_allocated_move_info(::Protocol::hyps_pos_info* move_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.move_info_);
  }
  if (move_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(move_info));
    if (message_arena != submessage_arena) {
      move_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, move_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.move_info_ = move_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_MOVE_OBJECT.move_info)
}

// .Protocol.hype_move_state move_state = 2;
inline void CS_MOVE_OBJECT::clear_move_state() {
  _impl_.move_state_ = 0;
}
inline ::Protocol::hype_move_state CS_MOVE_OBJECT::_internal_move_state() const {
  return static_cast< ::Protocol::hype_move_state >(_impl_.move_state_);
}
inline ::Protocol::hype_move_state CS_MOVE_OBJECT::move_state() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_MOVE_OBJECT.move_state)
  return _internal_move_state();
}
inline void CS_MOVE_OBJECT::_internal_set_move_state(::Protocol::hype_move_state value) {
  
  _impl_.move_state_ = value;
}
inline void CS_MOVE_OBJECT::set_move_state(::Protocol::hype_move_state value) {
  _internal_set_move_state(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_MOVE_OBJECT.move_state)
}

// -------------------------------------------------------------------

// SC_MOVE_OBJECT

// .Protocol.hyps_pos_info move_info = 1;
inline bool SC_MOVE_OBJECT::_internal_has_move_info() const {
  return this != internal_default_instance() && _impl_.move_info_ != nullptr;
}
inline bool SC_MOVE_OBJECT::has_move_info() const {
  return _internal_has_move_info();
}
inline const ::Protocol::hyps_pos_info& SC_MOVE_OBJECT::_internal_move_info() const {
  const ::Protocol::hyps_pos_info* p = _impl_.move_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::hyps_pos_info&>(
      ::Protocol::_hyps_pos_info_default_instance_);
}
inline const ::Protocol::hyps_pos_info& SC_MOVE_OBJECT::move_info() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_MOVE_OBJECT.move_info)
  return _internal_move_info();
}
inline void SC_MOVE_OBJECT::unsafe_arena_set_allocated_move_info(
    ::Protocol::hyps_pos_info* move_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.move_info_);
  }
  _impl_.move_info_ = move_info;
  if (move_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.SC_MOVE_OBJECT.move_info)
}
inline ::Protocol::hyps_pos_info* SC_MOVE_OBJECT::release_move_info() {
  
  ::Protocol::hyps_pos_info* temp = _impl_.move_info_;
  _impl_.move_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::hyps_pos_info* SC_MOVE_OBJECT::unsafe_arena_release_move_info() {
  // @@protoc_insertion_point(field_release:Protocol.SC_MOVE_OBJECT.move_info)
  
  ::Protocol::hyps_pos_info* temp = _impl_.move_info_;
  _impl_.move_info_ = nullptr;
  return temp;
}
inline ::Protocol::hyps_pos_info* SC_MOVE_OBJECT::_internal_mutable_move_info() {
  
  if (_impl_.move_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::hyps_pos_info>(GetArenaForAllocation());
    _impl_.move_info_ = p;
  }
  return _impl_.move_info_;
}
inline ::Protocol::hyps_pos_info* SC_MOVE_OBJECT::mutable_move_info() {
  ::Protocol::hyps_pos_info* _msg = _internal_mutable_move_info();
  // @@protoc_insertion_point(field_mutable:Protocol.SC_MOVE_OBJECT.move_info)
  return _msg;
}
inline void SC_MOVE_OBJECT::set_allocated_move_info(::Protocol::hyps_pos_info* move_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.move_info_);
  }
  if (move_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(move_info));
    if (message_arena != submessage_arena) {
      move_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, move_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.move_info_ = move_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.SC_MOVE_OBJECT.move_info)
}

// .Protocol.hype_move_state move_state = 2;
inline void SC_MOVE_OBJECT::clear_move_state() {
  _impl_.move_state_ = 0;
}
inline ::Protocol::hype_move_state SC_MOVE_OBJECT::_internal_move_state() const {
  return static_cast< ::Protocol::hype_move_state >(_impl_.move_state_);
}
inline ::Protocol::hype_move_state SC_MOVE_OBJECT::move_state() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_MOVE_OBJECT.move_state)
  return _internal_move_state();
}
inline void SC_MOVE_OBJECT::_internal_set_move_state(::Protocol::hype_move_state value) {
  
  _impl_.move_state_ = value;
}
inline void SC_MOVE_OBJECT::set_move_state(::Protocol::hype_move_state value) {
  _internal_set_move_state(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_MOVE_OBJECT.move_state)
}

// -------------------------------------------------------------------

// CS_CHAT

// string msg = 1;
inline void CS_CHAT::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& CS_CHAT::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_CHAT.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_CHAT::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CS_CHAT.msg)
}
inline std::string* CS_CHAT::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_CHAT.msg)
  return _s;
}
inline const std::string& CS_CHAT::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void CS_CHAT::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_CHAT::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_CHAT::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.CS_CHAT.msg)
  return _impl_.msg_.Release();
}
inline void CS_CHAT::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_CHAT.msg)
}

// -------------------------------------------------------------------

// SC_CHAT

// bool success = 1;
inline void SC_CHAT::clear_success() {
  _impl_.success_ = false;
}
inline bool SC_CHAT::_internal_success() const {
  return _impl_.success_;
}
inline bool SC_CHAT::success() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_CHAT.success)
  return _internal_success();
}
inline void SC_CHAT::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void SC_CHAT::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_CHAT.success)
}

// uint64 userId = 2;
inline void SC_CHAT::clear_userid() {
  _impl_.userid_ = uint64_t{0u};
}
inline uint64_t SC_CHAT::_internal_userid() const {
  return _impl_.userid_;
}
inline uint64_t SC_CHAT::userid() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_CHAT.userId)
  return _internal_userid();
}
inline void SC_CHAT::_internal_set_userid(uint64_t value) {
  
  _impl_.userid_ = value;
}
inline void SC_CHAT::set_userid(uint64_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_CHAT.userId)
}

// string msg = 3;
inline void SC_CHAT::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& SC_CHAT::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_CHAT.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SC_CHAT::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.SC_CHAT.msg)
}
inline std::string* SC_CHAT::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Protocol.SC_CHAT.msg)
  return _s;
}
inline const std::string& SC_CHAT::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void SC_CHAT::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* SC_CHAT::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* SC_CHAT::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.SC_CHAT.msg)
  return _impl_.msg_.Release();
}
inline void SC_CHAT::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.SC_CHAT.msg)
}

// -------------------------------------------------------------------

// BC_GL_CHAT

// string msg = 1;
inline void BC_GL_CHAT::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& BC_GL_CHAT::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.BC_GL_CHAT.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BC_GL_CHAT::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.BC_GL_CHAT.msg)
}
inline std::string* BC_GL_CHAT::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Protocol.BC_GL_CHAT.msg)
  return _s;
}
inline const std::string& BC_GL_CHAT::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void BC_GL_CHAT::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* BC_GL_CHAT::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* BC_GL_CHAT::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.BC_GL_CHAT.msg)
  return _impl_.msg_.Release();
}
inline void BC_GL_CHAT::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.BC_GL_CHAT.msg)
}

// -------------------------------------------------------------------

// CS_ECHO

// string msg = 1;
inline void CS_ECHO::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& CS_ECHO::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_ECHO.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_ECHO::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CS_ECHO.msg)
}
inline std::string* CS_ECHO::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_ECHO.msg)
  return _s;
}
inline const std::string& CS_ECHO::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void CS_ECHO::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_ECHO::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_ECHO::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.CS_ECHO.msg)
  return _impl_.msg_.Release();
}
inline void CS_ECHO::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_ECHO.msg)
}

// -------------------------------------------------------------------

// BC_GL_ECHO

// string msg = 1;
inline void BC_GL_ECHO::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& BC_GL_ECHO::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.BC_GL_ECHO.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BC_GL_ECHO::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.BC_GL_ECHO.msg)
}
inline std::string* BC_GL_ECHO::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Protocol.BC_GL_ECHO.msg)
  return _s;
}
inline const std::string& BC_GL_ECHO::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void BC_GL_ECHO::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* BC_GL_ECHO::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* BC_GL_ECHO::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.BC_GL_ECHO.msg)
  return _impl_.msg_.Release();
}
inline void BC_GL_ECHO::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.BC_GL_ECHO.msg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
